<!DOCTYPE HTML>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>RELAX NG Specification</title><link rel="stylesheet" type="text/css" href="tr.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><meta name="description" content="This is the definitive specification of RELAX NG, a simple schema language for XML, based on and . A RELAX NG schema specifies a pattern for the structure and content of an XML document. A RELAX NG schema is itself an XML document."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><p class="logo"><a href="http://www.oasis-open.org/"><img src="oasis.png" alt="OASIS" border="0"></a></p><div><h2 class="title"><a name="d61e1"></a>RELAX NG Specification</h2></div><div><h2>Committee Specification&nbsp;6 June 2002</h2></div><div><dl><dt>This version:</dt><dd>Committee Specification: 3 December 2001 (plus Errata: 6 June 2002)</dd></dl><dl><dt>Previous versions:</dt><dd>Committee Specification: 11 August 2001</dd></dl></div><div><dl><dt>Editors:</dt><dd>James Clark&nbsp;<code class="email">&lt;<a class="email" href="mailto:jjc@jclark.com">jjc@jclark.com</a>&gt;</code>, MURATA Makoto&nbsp;<code class="email">&lt;<a class="email" href="mailto:EB2M-MRT@asahi-net.or.jp">EB2M-MRT@asahi-net.or.jp</a>&gt;</code></dd></dl></div><div></div><div><div class="legalnotice"><a name="d61e32"></a><p>Copyright © The Organization for the Advancement of
Structured Information Standards [OASIS] 2001. All Rights
Reserved.</p><p>This document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defined in the OASIS Intellectual Property
Rights document must be followed, or as required to translate it into
languages other than English.</p><p>The limited permissions granted above are perpetual and will not
be revoked by OASIS or its successors or assigns.</p><p>This document and the information contained herein is provided
on an "<span class="quote">AS IS</span>" basis and OASIS DISCLAIMS ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p></div></div><div><hr><div class="abstract"><h2><a name="d61e54"></a>Abstract</h2><p>This is the definitive specification of RELAX NG, a simple
schema language for XML, based on <a class="xref" href="#relax">[<abbr class="abbrev">RELAX</abbr>]</a> and <a class="xref" href="#trex">[<abbr class="abbrev">TREX</abbr>]</a>. A RELAX NG schema specifies a pattern for the
structure and content of an XML document. A RELAX NG schema is itself
an XML document.</p></div></div><div><div class="legalnotice"><h2>Status of this Document</h2><p>This Committee Specification was approved for publication by the
OASIS RELAX NG technical committee. It is a stable document which
represents the consensus of the committee. Comments on this document
may be sent to <a class="ulink" href="mailto:relax-ng-comment@lists.oasis-open.org" target="_top">relax-ng-comment@lists.oasis-open.org</a>.</p><p>A list of known errors was applied to this document <a class="ulink" href="http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html" target="_top">http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html</a>.</p></div></div></div><div class="toc"><h2>Table of Contents</h2><dl><dt><span class="section"><a href="#d61e70">1. Introduction</a></span></dt><dt><span class="section"><a href="#data-model">2. Data model</a></span></dt><dd><dl><dt><span class="section"><a href="#data-model-example">2.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#full-syntax">3. Full syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#full-syntax-example">3.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#simplification">4. Simplification</a></span></dt><dd><dl><dt><span class="section"><a href="#d61e340">4.1. Annotations</a></span></dt><dt><span class="section"><a href="#d61e352">4.2. Whitespace</a></span></dt><dt><span class="section"><a href="#d61e370">4.3. <code class="literal">datatypeLibrary</code> attribute</a></span></dt><dt><span class="section"><a href="#d61e403">4.4. <code class="literal">type</code> attribute of <code class="literal">value</code> element</a></span></dt><dt><span class="section"><a href="#href">4.5. <code class="literal">href</code> attribute</a></span></dt><dt><span class="section"><a href="#d61e471">4.6. <code class="literal">externalRef</code> element</a></span></dt><dt><span class="section"><a href="#d61e497">4.7. <code class="literal">include</code> element</a></span></dt><dt><span class="section"><a href="#d61e590">4.8. <code class="literal">name</code> attribute of <code class="literal">element</code>
and <code class="literal">attribute</code> elements</a></span></dt><dt><span class="section"><a href="#d61e620">4.9. <code class="literal">ns</code> attribute</a></span></dt><dt><span class="section"><a href="#d61e679">4.10. QNames</a></span></dt><dt><span class="section"><a href="#d61e693">4.11. <code class="literal">div</code> element</a></span></dt><dt><span class="section"><a href="#number-child-elements">4.12. Number of child elements</a></span></dt><dt><span class="section"><a href="#d61e762">4.13. <code class="literal">mixed</code> element</a></span></dt><dt><span class="section"><a href="#d61e781">4.14. <code class="literal">optional</code> element</a></span></dt><dt><span class="section"><a href="#d61e804">4.15. <code class="literal">zeroOrMore</code> element</a></span></dt><dt><span class="section"><a href="#constraints">4.16. Constraints</a></span></dt><dt><span class="section"><a href="#d61e914">4.17. <code class="literal">combine</code> attribute</a></span></dt><dt><span class="section"><a href="#d61e1002">4.18. <code class="literal">grammar</code> element</a></span></dt><dt><span class="section"><a href="#define-ref">4.19. <code class="literal">define</code> and <code class="literal">ref</code> elements</a></span></dt><dt><span class="section"><a href="#notAllowed">4.20. <code class="literal">notAllowed</code> element</a></span></dt><dt><span class="section"><a href="#d61e1237">4.21. <code class="literal">empty</code> element</a></span></dt></dl></dd><dt><span class="section"><a href="#simple-syntax">5. Simple syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#simple-syntax-example">5.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#semantics">6. Semantics</a></span></dt><dd><dl><dt><span class="section"><a href="#name-classes">6.1. Name classes</a></span></dt><dt><span class="section"><a href="#d61e1591">6.2. Patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#choice-pattern">6.2.1. <code class="literal">choice</code> pattern</a></span></dt><dt><span class="section"><a href="#d61e1715">6.2.2. <code class="literal">group</code> pattern</a></span></dt><dt><span class="section"><a href="#empty-pattern">6.2.3. <code class="literal">empty</code> pattern</a></span></dt><dt><span class="section"><a href="#text-pattern">6.2.4. <code class="literal">text</code> pattern</a></span></dt><dt><span class="section"><a href="#d61e1933">6.2.5. <code class="literal">oneOrMore</code> pattern</a></span></dt><dt><span class="section"><a href="#d61e2047">6.2.6. <code class="literal">interleave</code> pattern</a></span></dt><dt><span class="section"><a href="#element-pattern">6.2.7. <code class="literal">element</code> and <code class="literal">attribute</code> pattern</a></span></dt><dt><span class="section"><a href="#data-pattern">6.2.8. <code class="literal">data</code> and <code class="literal">value</code> pattern</a></span></dt><dt><span class="section"><a href="#built-in-datatype">6.2.9. Built-in datatype library</a></span></dt><dt><span class="section"><a href="#d61e3081">6.2.10. <code class="literal">list</code> pattern</a></span></dt></dl></dd><dt><span class="section"><a href="#validity">6.3. Validity</a></span></dt><dt><span class="section"><a href="#d61e3199">6.4. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#restriction">7. Restrictions</a></span></dt><dd><dl><dt><span class="section"><a href="#contextual-restriction">7.1. Contextual restrictions</a></span></dt><dd><dl><dt><span class="section"><a href="#d61e3695">7.1.1. <code class="literal">attribute</code> pattern</a></span></dt><dt><span class="section"><a href="#d61e3707">7.1.2. <code class="literal">oneOrMore</code> pattern</a></span></dt><dt><span class="section"><a href="#list-restrictions">7.1.3. <code class="literal">list</code> pattern</a></span></dt><dt><span class="section"><a href="#context-data-except">7.1.4. <code class="literal">except</code> in <code class="literal">data</code> pattern</a></span></dt><dt><span class="section"><a href="#context-start">7.1.5. <code class="literal">start</code> element</a></span></dt></dl></dd><dt><span class="section"><a href="#string-sequences">7.2. String sequences</a></span></dt><dt><span class="section"><a href="#attribute-restrictions">7.3. Restrictions on attributes</a></span></dt><dt><span class="section"><a href="#interleave-restrictions">7.4. Restrictions on <code class="literal">interleave</code></a></span></dt></dl></dd><dt><span class="section"><a href="#conformance">8. Conformance</a></span></dt></dl><h3>Appendixes</h3><dl><dt><span class="appendix"><a href="#d61e4435">A. RELAX NG schema for RELAX NG</a></span></dt><dt><span class="appendix"><a href="#d61e4438">B. Changes since version 0.9</a></span></dt><dt><span class="appendix"><a href="#d61e4547">C. RELAX NG TC (Non-Normative)</a></span></dt><dt><span class="bibliography"><a href="#d61e4567">References</a></span></dt></dl></div><hr><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d61e70"></a>1.&nbsp;Introduction</h2></div></div><p>This document specifies</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e74"></a>when an XML document is a correct RELAX NG
schema</li><li class="listitem"><a name="d61e76"></a>when an XML document is valid with respect to a
correct RELAX NG schema</li></ul></div><p>An XML document that is being validated with respect to a RELAX NG
schema is referred to as an instance.</p><p>The structure of this document is as follows.  <a class="xref" href="#data-model" title="2.&nbsp;Data model">Section&nbsp;2, &#x201c;Data model&#x201d;</a> describes the data model, which is the
abstraction of an XML document used throughout the rest of the
document.  <a class="xref" href="#full-syntax" title="3.&nbsp;Full syntax">Section&nbsp;3, &#x201c;Full syntax&#x201d;</a> describes the syntax of a
RELAX NG schema; any correct RELAX NG schema must conform to this
syntax.  <a class="xref" href="#simplification" title="4.&nbsp;Simplification">Section&nbsp;4, &#x201c;Simplification&#x201d;</a> describes a sequence of
transformations that are applied to simplify a RELAX NG schema;
applying the transformations also involves checking certain
restrictions that must be satisfied by a correct RELAX NG
schema. <a class="xref" href="#simple-syntax" title="5.&nbsp;Simple syntax">Section&nbsp;5, &#x201c;Simple syntax&#x201d;</a> describes the syntax that
results from applying the transformations; this simple syntax is a
subset of the full syntax.  <a class="xref" href="#semantics" title="6.&nbsp;Semantics">Section&nbsp;6, &#x201c;Semantics&#x201d;</a> describes the
semantics of a correct RELAX NG schema that uses the simple syntax;
the semantics specify when an element is valid with respect to a RELAX
NG schema.  <a class="xref" href="#restriction" title="7.&nbsp;Restrictions">Section&nbsp;7, &#x201c;Restrictions&#x201d;</a> describes restrictions in
terms of the simple syntax; a correct RELAX NG schema must be such
that, after transformation into the simple form, it satisfies these
restrictions. Finally, <a class="xref" href="#conformance" title="8.&nbsp;Conformance">Section&nbsp;8, &#x201c;Conformance&#x201d;</a> describes
conformance requirements for RELAX NG validators.</p><p>A tutorial is available separately (see <a class="xref" href="#tutorial">[<abbr class="abbrev">Tutorial</abbr>]</a>).</p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="data-model"></a>2.&nbsp;Data model</h2></div></div><p>RELAX NG deals with XML documents representing both schemas and
instances through an abstract data model.  XML documents representing
schemas and instances must be well-formed in conformance with <a class="xref" href="#xml-rec">[<abbr class="abbrev">XML 1.0</abbr>]</a> and must conform to the constraints of <a class="xref" href="#xml-names">[<abbr class="abbrev">XML Namespaces</abbr>]</a>.</p><p>An XML document is represented by an element.  An element consists
of</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e110"></a>a name</li><li class="listitem"><a name="d61e112"></a>a context</li><li class="listitem"><a name="d61e114"></a>a set of attributes</li><li class="listitem"><a name="d61e116"></a>an ordered sequence of zero or more children; each
child is either an element or a non-empty string; the sequence never contains
two consecutive strings</li></ul></div><p>A name consists of</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e120"></a>a string representing the namespace URI; the empty
string has special significance, representing the absence of any
namespace</li><li class="listitem"><a name="d61e122"></a>a string representing the local name; this string matches the NCName
production of <a class="xref" href="#xml-names">[<abbr class="abbrev">XML Namespaces</abbr>]</a></li></ul></div><p>A context consists of</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e128"></a>a base URI</li><li class="listitem"><a name="d61e130"></a>a namespace map; this maps prefixes to namespace URIs,
and also may specify a default namespace URI (as declared
by the <code class="literal">xmlns</code> attribute)</li></ul></div><p>An attribute consists of</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e137"></a>a name</li><li class="listitem"><a name="d61e139"></a>a string representing the value</li></ul></div><p>A string consists of a sequence of zero or more characters,
where a character is as defined in <a class="xref" href="#xml-rec">[<abbr class="abbrev">XML 1.0</abbr>]</a>.</p><p>The element for an XML document is constructed from an instance
of the <a class="xref" href="#infoset">[<abbr class="abbrev">XML Infoset</abbr>]</a> as follows.  We use the notation
[<em class="replaceable"><code>x</code></em>] to refer to the value of the
<em class="replaceable"><code>x</code></em> property of an information item. An
element is constructed from a document information item by
constructing an element from the [document element].  An element is
constructed from an element information item by constructing the name
from the [namespace name] and [local name], the context from the [base
URI] and [in-scope namespaces], the attributes from the [attributes],
and the children from the [children].  The attributes of an element
are constructed from the unordered set of attribute information items
by constructing an attribute for each attribute information item.  The
children of an element are constructed from the list of child
information items first by removing information items other than
element information items and character information items, and then by
constructing an element for each element information item in the list
and a string for each maximal sequence of character information items.
An attribute is constructed from an attribute information item by
constructing the name from the [namespace name] and [local name], and
the value from the [normalized value].  When constructing the name of
an element or attribute from the [namespace name] and [local name], if
the [namespace name] property is not present, then the name is
constructed from an empty string and the [local name]. A string is
constructed from a sequence of character information items by
constructing a character from the [character code] of each character
information item.</p><p>It is possible for there to be multiple distinct infosets for a
single XML document.  This is because XML parsers are not required to
process all DTD declarations or expand all external parsed general
entities.  Amongst these multiple infosets, there is exactly one
infoset for which [all declarations processed] is true and which does
not contain any unexpanded entity reference information items.  This
is the infoset that is the basis for defining the RELAX NG data
model.</p><div class="section"><div class="titlepage"><div><h3 class="title"><a name="data-model-example"></a>2.1.&nbsp;Example</h3></div></div><p>Suppose the document
<code class="literal">http://www.example.com/doc.xml</code> is as
follows:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;foo&gt;&lt;pre1:bar1 xmlns:pre1="http://www.example.com/n1"/&gt;&lt;pre2:bar2
  xmlns:pre2="http://www.example.com/n2"/&gt;&lt;/foo&gt;
</pre><p>The element representing this document has</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e164"></a>a name which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><a name="d61e167"></a>the empty string as the namespace URI, representing
the absence of any namespace</li><li class="listitem"><a name="d61e169"></a><code class="literal">foo</code> as the local
name</li></ul></div></li><li class="listitem"><a name="d61e173"></a>a context which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><a name="d61e176"></a><code class="literal">http://www.example.com/doc.xml</code> as the base
URI</li><li class="listitem"><a name="d61e180"></a>a namespace map which<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><a name="d61e183"></a>maps the prefix <code class="literal">xml</code> to the
namespace URI
<code class="literal">http://www.w3.org/XML/1998/namespace</code>
(the <code class="literal">xml</code> prefix is implicitly declared
by every XML document)</li><li class="listitem"><a name="d61e192"></a>specifies the empty string as the default namespace
URI</li></ul></div></li></ul></div></li><li class="listitem"><a name="d61e194"></a>an empty set of attributes</li><li class="listitem"><a name="d61e196"></a>a sequence of children consisting
of an element which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><a name="d61e199"></a>a name which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><a name="d61e202"></a><code class="literal">http://www.example.com/n1</code> as the
namespace URI</li><li class="listitem"><a name="d61e206"></a><code class="literal">bar1</code> as the local
name</li></ul></div></li><li class="listitem"><a name="d61e210"></a>a context which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><a name="d61e213"></a><code class="literal">http://www.example.com/doc.xml</code> as the base
URI</li><li class="listitem"><a name="d61e217"></a>a namespace map which<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e220"></a>maps the prefix <code class="literal">pre1</code> to the
namespace URI
<code class="literal">http://www.example.com/n1</code></li><li class="listitem"><a name="d61e226"></a>maps the prefix <code class="literal">xml</code> to the
namespace URI
<code class="literal">http://www.w3.org/XML/1998/namespace</code></li><li class="listitem"><a name="d61e232"></a>specifies the empty string as the default namespace
URI</li></ul></div></li></ul></div></li><li class="listitem"><a name="d61e234"></a>an empty set of attributes</li><li class="listitem"><a name="d61e236"></a>an empty sequence of children</li></ul></div><p>followed by an element which has</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><a name="d61e240"></a>a name which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><a name="d61e243"></a><code class="literal">http://www.example.com/n2</code> as the
namespace URI</li><li class="listitem"><a name="d61e247"></a><code class="literal">bar2</code> as the local
name</li></ul></div></li><li class="listitem"><a name="d61e251"></a>a context which has<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><a name="d61e254"></a><code class="literal">http://www.example.com/doc.xml</code> as the base
URI</li><li class="listitem"><a name="d61e258"></a>a namespace map which<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e261"></a>maps the prefix <code class="literal">pre2</code> to the
namespace URI
<code class="literal">http://www.example.com/n2</code></li><li class="listitem"><a name="d61e267"></a>maps the prefix <code class="literal">xml</code> to the
namespace URI
<code class="literal">http://www.w3.org/XML/1998/namespace</code></li><li class="listitem"><a name="d61e273"></a>specifies the empty string as the default namespace
URI</li></ul></div></li></ul></div></li><li class="listitem"><a name="d61e275"></a>an empty set of attributes</li><li class="listitem"><a name="d61e277"></a>an empty sequence of children</li></ul></div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="full-syntax"></a>3.&nbsp;Full syntax</h2></div></div><p>The following grammar summarizes the syntax of RELAX NG.
Although we use a notation based on the XML representation of an RELAX
NG schema as a sequence of characters, the grammar must be understood
as operating at the data model level.  For example, although the
syntax uses <code class="literal">&lt;text/&gt;</code>, an instance or
schema can use <code class="literal">&lt;text&gt;&lt;/text&gt;</code> instead,
because they both represent the same element at the data model level.
All elements shown in the grammar are qualified with the namespace
URI:</p><pre class="programlisting">http://relaxng.org/ns/structure/1.0</pre><p>The symbols QName and NCName are defined in <a class="xref" href="#xml-names">[<abbr class="abbrev">XML Namespaces</abbr>]</a>.  The anyURI symbol has the same meaning as the
anyURI datatype of <a class="xref" href="#xmlschema-2">[<abbr class="abbrev">W3C XML Schema Datatypes</abbr>]</a>: it indicates a
string that, after escaping of disallowed values as described in
Section 5.4 of <a class="xref" href="#xlink">[<abbr class="abbrev">XLink</abbr>]</a>, is a URI reference as defined
in <a class="xref" href="#rfc2396">[<abbr class="abbrev">RFC 2396</abbr>]</a> (as modified by <a class="xref" href="#rfc2732">[<abbr class="abbrev">RFC 2732</abbr>]</a>).  The symbol string matches any string.</p><p>In addition to the attributes shown explicitly, any element can
have an <code class="literal">ns</code> attribute and any element can have a
<code class="literal">datatypeLibrary</code> attribute. The
<code class="literal">ns</code> attribute can have any value.  The value of the
<code class="literal">datatypeLibrary</code> attribute must match the anyURI
symbol as described in the previous paragraph; in addition, it must
not use the relative form of URI reference and must not have a
fragment identifier; as an exception to this, the value may be the
empty string.</p><p>Any element can also have foreign attributes in addition to the
attributes shown in the grammar. A foreign attribute is an attribute
with a name whose namespace URI is neither the empty string nor the
RELAX NG namespace URI.  Any element that cannot have string children
(that is, any element other than <code class="literal">value</code>, <code class="literal">param</code>
and <code class="literal">name</code>) may have foreign child elements in addition
to the child elements shown in the grammar. A foreign element is an
element with a name whose namespace URI is not the RELAX NG namespace
URI.  There are no constraints on the relative position of foreign
child elements with respect to other child elements.</p><p>Any element can also have as children strings that consist
entirely of whitespace characters, where a whitespace character is one
of #x20, #x9, #xD or #xA. There are no constraints on the relative
position of whitespace string children with respect to child
elements.</p><p>Leading and trailing whitespace is allowed for value of each
<code class="literal">name</code>, <code class="literal">type</code> and
<code class="literal">combine</code> attribute and for the content of each
<code class="literal">name</code> element.</p><html><head><title></title><link rel="stylesheet" type="text/css" href="tr.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table><tr valign="baseline"><td>pattern</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;element</code> <code>name="</code><i>QName</i><code>"</code><code>&gt; </code><i>pattern</i>+<code> &lt;/element&gt;</code><br>| <code>&lt;element</code><code>&gt; </code><i>nameClass</i> <i>pattern</i>+<code> &lt;/element&gt;</code><br>| <code>&lt;attribute</code> <code>name="</code><i>QName</i><code>"</code><code>&gt; </code>[<i>pattern</i>]<code> &lt;/attribute&gt;</code><br>| <code>&lt;attribute</code><code>&gt; </code><i>nameClass</i> [<i>pattern</i>]<code> &lt;/attribute&gt;</code><br>| <code>&lt;group</code><code>&gt; </code><i>pattern</i>+<code> &lt;/group&gt;</code><br>| <code>&lt;interleave</code><code>&gt; </code><i>pattern</i>+<code> &lt;/interleave&gt;</code><br>| <code>&lt;choice</code><code>&gt; </code><i>pattern</i>+<code> &lt;/choice&gt;</code><br>| <code>&lt;optional</code><code>&gt; </code><i>pattern</i>+<code> &lt;/optional&gt;</code><br>| <code>&lt;zeroOrMore</code><code>&gt; </code><i>pattern</i>+<code> &lt;/zeroOrMore&gt;</code><br>| <code>&lt;oneOrMore</code><code>&gt; </code><i>pattern</i>+<code> &lt;/oneOrMore&gt;</code><br>| <code>&lt;list</code><code>&gt; </code><i>pattern</i>+<code> &lt;/list&gt;</code><br>| <code>&lt;mixed</code><code>&gt; </code><i>pattern</i>+<code> &lt;/mixed&gt;</code><br>| <code>&lt;ref</code> <code>name="</code><i>NCName</i><code>"</code><code>/&gt;</code><br>| <code>&lt;parentRef</code> <code>name="</code><i>NCName</i><code>"</code><code>/&gt;</code><br>| <code>&lt;empty</code><code>/&gt;</code><br>| <code>&lt;text</code><code>/&gt;</code><br>| <code>&lt;value</code> [<code>type="</code><i>NCName</i><code>"</code>]<code>&gt; </code><i>string</i><code> &lt;/value&gt;</code><br>| <code>&lt;data</code> <code>type="</code><i>NCName</i><code>"</code><code>&gt; </code><i>param</i>* [<i>exceptPattern</i>]<code> &lt;/data&gt;</code><br>| <code>&lt;notAllowed</code><code>/&gt;</code><br>| <code>&lt;externalRef</code> <code>href="</code><i>anyURI</i><code>"</code><code>/&gt;</code><br>| <code>&lt;grammar</code><code>&gt; </code><i>grammarContent</i>*<code> &lt;/grammar&gt;</code></td></tr><tr valign="baseline"><td>param</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;param</code> <code>name="</code><i>NCName</i><code>"</code><code>&gt; </code><i>string</i><code> &lt;/param&gt;</code></td></tr><tr valign="baseline"><td>exceptPattern</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;except</code><code>&gt; </code><i>pattern</i>+<code> &lt;/except&gt;</code></td></tr><tr valign="baseline"><td>grammarContent</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><i>start</i><br>| <i>define</i><br>| <code>&lt;div</code><code>&gt; </code><i>grammarContent</i>*<code> &lt;/div&gt;</code><br>| <code>&lt;include</code> <code>href="</code><i>anyURI</i><code>"</code><code>&gt; </code><i>includeContent</i>*<code> &lt;/include&gt;</code></td></tr><tr valign="baseline"><td>includeContent</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><i>start</i><br>| <i>define</i><br>| <code>&lt;div</code><code>&gt; </code><i>includeContent</i>*<code> &lt;/div&gt;</code></td></tr><tr valign="baseline"><td>start</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;start</code> [<code>combine="</code><i>method</i><code>"</code>]<code>&gt; </code><i>pattern</i><code> &lt;/start&gt;</code></td></tr><tr valign="baseline"><td>define</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;define</code> <code>name="</code><i>NCName</i><code>"</code> [<code>combine="</code><i>method</i><code>"</code>]<code>&gt; </code><i>pattern</i>+<code> &lt;/define&gt;</code></td></tr><tr valign="baseline"><td>method</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>choice</code><br>| <code>interleave</code></td></tr><tr valign="baseline"><td>nameClass</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;name</code><code>&gt; </code><i>QName</i><code> &lt;/name&gt;</code><br>| <code>&lt;anyName</code><code>&gt; </code>[<i>exceptNameClass</i>]<code> &lt;/anyName&gt;</code><br>| <code>&lt;nsName</code><code>&gt; </code>[<i>exceptNameClass</i>]<code> &lt;/nsName&gt;</code><br>| <code>&lt;choice</code><code>&gt; </code><i>nameClass</i>+<code> &lt;/choice&gt;</code></td></tr><tr valign="baseline"><td>exceptNameClass</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;except</code><code>&gt; </code><i>nameClass</i>+<code> &lt;/except&gt;</code></td></tr></table></body></html><div class="section"><div class="titlepage"><div><h3 class="title"><a name="full-syntax-example"></a>3.1.&nbsp;Example</h3></div></div><p>Here is an example of a schema in the full syntax for the
document in <a class="xref" href="#data-model-example" title="2.1.&nbsp;Example">Section&nbsp;2.1, &#x201c;Example&#x201d;</a>.</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;element name="foo"
         xmlns="http://relaxng.org/ns/structure/1.0"
         xmlns:a="http://relaxng.org/ns/annotation/1.0"
         xmlns:ex1="http://www.example.com/n1"
         xmlns:ex2="http://www.example.com/n2"&gt;
  &lt;a:documentation&gt;A foo element.&lt;/a:documentation&gt;
  &lt;element name="ex1:bar1"&gt;
    &lt;empty/&gt;
  &lt;/element&gt;
  &lt;element name="ex2:bar2"&gt;
    &lt;empty/&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="simplification"></a>4.&nbsp;Simplification</h2></div></div><p>The full syntax given in the previous section is transformed
into a simpler syntax by applying the following transformation rules
in order. The effect must be as if each rule was applied to all
elements in the schema before the next rule is applied.  A
transformation rule may also specify constraints that must be
satisfied by a correct schema. The transformation rules are applied
at the data model level.  Before the transformations are applied, the
schema is parsed into an instance of the data model.</p><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e340"></a>4.1.&nbsp;Annotations</h3></div></div><p>Foreign attributes and elements are removed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is safe to remove <code class="literal">xml:base</code>
attributes at this stage because <code class="literal">xml:base</code>
attributes are used in determining the [base URI] of an element
information item, which is in turn used to construct the base URI of
the context of an element.  Thus, after a document has been parsed
into an instance of the data model, <code class="literal">xml:base</code>
attributes can be discarded.</p></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e352"></a>4.2.&nbsp;Whitespace</h3></div></div><p>For each element other than <code class="literal">value</code> and
<code class="literal">param</code>, each child that is a string containing only
whitespace characters is removed.</p><p>Leading and trailing whitespace characters are removed from the
value of each <code class="literal">name</code>, <code class="literal">type</code> and
<code class="literal">combine</code> attribute and from the content of each
<code class="literal">name</code> element.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e370"></a>4.3.&nbsp;<code class="literal">datatypeLibrary</code> attribute</h3></div></div><p>The value of each <code class="literal">datatypeLibary</code> attribute is
transformed by escaping disallowed characters as specified in Section
5.4 of <a class="xref" href="#xlink">[<abbr class="abbrev">XLink</abbr>]</a>.</p><p>For any <code class="literal">data</code> or <code class="literal">value</code>
element that does not have a <code class="literal">datatypeLibrary</code>
attribute, a <code class="literal">datatypeLibrary</code> attribute is
added. The value of the added <code class="literal">datatypeLibrary</code>
attribute is the value of the <code class="literal">datatypeLibrary</code>
attribute of the nearest ancestor element that has a
<code class="literal">datatypeLibrary</code> attribute, or the empty string if
there is no such ancestor. Then, any <code class="literal">datatypeLibrary</code>
attribute that is on an element other than <code class="literal">data</code> or
<code class="literal">value</code> is removed.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e403"></a>4.4.&nbsp;<code class="literal">type</code> attribute of <code class="literal">value</code> element</h3></div></div><p>For any <code class="literal">value</code> element that does not have a
<code class="literal">type</code> attribute, a <code class="literal">type</code> attribute
is added with value <code class="literal">token</code> and the value of the
<code class="literal">datatypeLibrary</code> attribute is changed to the empty
string.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="href"></a>4.5.&nbsp;<code class="literal">href</code> attribute</h3></div></div><p>The value of the <code class="literal">href</code> attribute on an
<code class="literal">externalRef</code> or <code class="literal">include</code> element
is first transformed by escaping disallowed characters as specified in
Section 5.4 of <a class="xref" href="#xlink">[<abbr class="abbrev">XLink</abbr>]</a>.  The URI reference is then
resolved into an absolute form as described in section 5.2 of <a class="xref" href="#rfc2396">[<abbr class="abbrev">RFC 2396</abbr>]</a> using the base URI from the context of the element
that bears the <code class="literal">href</code> attribute.</p><p>The value of the <code class="literal">href</code> attribute will be used
to construct an element (as specified in <a class="xref" href="#data-model" title="2.&nbsp;Data model">Section&nbsp;2, &#x201c;Data model&#x201d;</a>). This must be done as follows.  The URI
reference consists of the URI itself and an optional fragment
identifier. The resource identified by the URI is retrieved.  The
result is a MIME entity: a sequence of bytes labeled with a MIME
media type.  The media type determines how an element is constructed
from the MIME entity and optional fragment identifier.  When the media
type is <code class="literal">application/xml</code> or
<code class="literal">text/xml</code>, the MIME entity must be parsed as an XML
document in accordance with the applicable RFC (at the term of writing
<a class="xref" href="#rfc3023">[<abbr class="abbrev">RFC 3023</abbr>]</a>) and an element constructed from the result
of the parse as specified in <a class="xref" href="#data-model" title="2.&nbsp;Data model">Section&nbsp;2, &#x201c;Data model&#x201d;</a>.  In
particular, the <code class="literal">charset</code> parameter must be handled
as specified by the RFC. This specification does not define the
handling of media types other than <code class="literal">application/xml</code>
and <code class="literal">text/xml</code>. The <code class="literal">href</code> attribute
must not include a fragment identifier unless the registration of the
media type of the resource identified by the attribute defines the
interpretation of fragment identifiers for that media type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><a class="xref" href="#rfc3023">[<abbr class="abbrev">RFC 3023</abbr>]</a> does not define the
interpretation of fragment identifiers for
<code class="literal">application/xml</code> or
<code class="literal">text/xml</code>.</p></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e471"></a>4.6.&nbsp;<code class="literal">externalRef</code> element</h3></div></div><p>An <code class="literal">externalRef</code> element is transformed as
follows.  An element is constructed using the URI reference that is
the value of <code class="literal">href</code> attribute as specified in <a class="xref" href="#href" title="4.5.&nbsp;href attribute">Section&nbsp;4.5, &#x201c;<code class="literal">href</code> attribute&#x201d;</a>. This element must match the syntax for pattern.  The
element is transformed by recursively applying the rules from this
subsection and from previous subsections of this section. This must
not result in a loop. In other words, the transformation of the
referenced element must not require the dereferencing of an
<code class="literal">externalRef</code> attribute with an
<code class="literal">href</code> attribute with the same value.</p><p>Any <code class="literal">ns</code> attribute on the
<code class="literal">externalRef</code> element is transferred to the
referenced element if the referenced element does not already have an
<code class="literal">ns</code> attribute.  The <code class="literal">externalRef</code>
element is then replaced by the referenced element.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e497"></a>4.7.&nbsp;<code class="literal">include</code> element</h3></div></div><p>An <code class="literal">include</code> element is transformed as follows.
An element is constructed using the URI reference that is the value of
<code class="literal">href</code> attribute as specified in <a class="xref" href="#href" title="4.5.&nbsp;href attribute">Section&nbsp;4.5, &#x201c;<code class="literal">href</code> attribute&#x201d;</a>.  This element must be a <code class="literal">grammar</code>
element, matching the syntax for grammar.</p><p>This <code class="literal">grammar</code> element is transformed by
recursively applying the rules from this subsection and from previous
subsections of this section.  This must not result in a loop. In other
words, the transformation of the <code class="literal">grammar</code> element
must not require the dereferencing of an <code class="literal">include</code>
element with an <code class="literal">href</code> attribute with the same
value.</p><p>Define the <em class="firstterm">components</em> of an element to
be the children of the element together with the components of any
<code class="literal">div</code> child elements.  If the
<code class="literal">include</code> element has a <code class="literal">start</code>
component, then the <code class="literal">grammar</code> element must have a
<code class="literal">start</code> component.  If the <code class="literal">include</code>
element has a <code class="literal">start</code> component, then all
<code class="literal">start</code> components are removed from the
<code class="literal">grammar</code> element.  If the <code class="literal">include</code>
element has a <code class="literal">define</code> component, then the
<code class="literal">grammar</code> element must have a
<code class="literal">define</code> component with the same name.  For every
<code class="literal">define</code> component of the <code class="literal">include</code>
element, all <code class="literal">define</code> components with the same name
are removed from the <code class="literal">grammar</code> element.</p><p>The <code class="literal">include</code> element is transformed into a
<code class="literal">div</code> element.  The attributes of the
<code class="literal">div</code> element are the attributes of the
<code class="literal">include</code> element other than the
<code class="literal">href</code> attribute.  The children of the
<code class="literal">div</code> element are the <code class="literal">grammar</code>
element (after the removal of the <code class="literal">start</code> and
<code class="literal">define</code> components described by the preceding
paragraph) followed by the children of the <code class="literal">include</code>
element.  The <code class="literal">grammar</code> element is then renamed to
<code class="literal">div</code>.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e590"></a>4.8.&nbsp;<code class="literal">name</code> attribute of <code class="literal">element</code>
and <code class="literal">attribute</code> elements</h3></div></div><p>The <code class="literal">name</code> attribute on an
<code class="literal">element</code> or <code class="literal">attribute</code> element is
transformed into a <code class="literal">name</code> child element.</p><p>If an <code class="literal">attribute</code> element has a
<code class="literal">name</code> attribute but no <code class="literal">ns</code>
attribute, then an <code class="literal">ns=""</code> attribute is added to the
<code class="literal">name</code> child element.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e620"></a>4.9.&nbsp;<code class="literal">ns</code> attribute</h3></div></div><p>For any <code class="literal">name</code>, <code class="literal">nsName</code> or
<code class="literal">value</code> element that does not have an
<code class="literal">ns</code> attribute, an <code class="literal">ns</code> attribute is
added. The value of the added <code class="literal">ns</code> attribute is the
value of the <code class="literal">ns</code> attribute of the nearest ancestor
element that has an <code class="literal">ns</code> attribute, or the empty
string if there is no such ancestor. Then, any <code class="literal">ns</code>
attribute that is on an element other than <code class="literal">name</code>,
<code class="literal">nsName</code> or <code class="literal">value</code> is
removed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The value of the <code class="literal">ns</code> attribute is
<span class="strong"><strong>not</strong></span> transformed either by escaping
disallowed characters, or in any other way, because the value of the
<code class="literal">ns</code> attribute is compared against namespace URIs in
the instance, which are not subject to any
transformation.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Since <code class="literal">include</code> and
<code class="literal">externalRef</code> elements are resolved after
<code class="literal">datatypeLibrary</code> attributes are added but before
<code class="literal">ns</code> attributes are added, <code class="literal">ns</code>
attributes are inherited into external schemas but
<code class="literal">datatypeLibrary</code> attributes are not.</p></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e679"></a>4.10.&nbsp;QNames</h3></div></div><p>For any <code class="literal">name</code> element containing a prefix, the
prefix is removed and an <code class="literal">ns</code> attribute is added
replacing any existing <code class="literal">ns</code> attribute. The value of
the added <code class="literal">ns</code> attribute is the value to which the
namespace map of the context of the <code class="literal">name</code> element
maps the prefix.  The context must have a mapping for the
prefix.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e693"></a>4.11.&nbsp;<code class="literal">div</code> element</h3></div></div><p>Each <code class="literal">div</code> element is replaced by its
children.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="number-child-elements"></a>4.12.&nbsp;Number of child elements</h3></div></div><p>A <code class="literal">define</code>, <code class="literal">oneOrMore</code>,
<code class="literal">zeroOrMore</code>, <code class="literal">optional</code>, <code class="literal">list</code> or
<code class="literal">mixed</code> element is transformed so that it has exactly
one child element.  If it has more than one child element, then its
child elements are wrapped in a <code class="literal">group</code>
element. Similarly, an <code class="literal">element</code> element is transformed so
that it has exactly two child elements, the first being a name class
and the second being a pattern. If it has more than two child elements,
then the child elements other than the first are wrapped in a
<code class="literal">group</code> element.</p><p>A <code class="literal">except</code> element is transformed
so that it has exactly one child element. If it has more
than one child element, then its child elements are wrapped
in a <code class="literal">choice</code> element.</p><p>If an <code class="literal">attribute</code> element has only one child
element (a name class), then a <code class="literal">text</code> element is
added.</p><p>A <code class="literal">choice</code>, <code class="literal">group</code> or
<code class="literal">interleave</code> element is transformed so that it has
exactly two child elements. If it has one child element, then it is
replaced by its child element.  If it has more than two child
elements, then the first two child elements are combined into a new
element with the same name as the parent element and with the first
two child elements as its children.  For example,</p><pre class="programlisting">&lt;choice&gt; <em class="replaceable"><code>p1</code></em> <em class="replaceable"><code>p2</code></em> <em class="replaceable"><code>p3</code></em> &lt;/choice&gt;</pre><p>is transformed to</p><pre class="programlisting">&lt;choice&gt; &lt;choice&gt; <em class="replaceable"><code>p1</code></em> <em class="replaceable"><code>p2</code></em> &lt;/choice&gt; <em class="replaceable"><code>p3</code></em> &lt;/choice&gt;</pre><p>This reduces the number of child elements by one. The
transformation is applied repeatedly until there are exactly two child
elements.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e762"></a>4.13.&nbsp;<code class="literal">mixed</code> element</h3></div></div><p>A <code class="literal">mixed</code> element is transformed into an
interleaving with a <code class="literal">text</code> element:</p><pre class="programlisting">&lt;mixed&gt; <em class="replaceable"><code>p</code></em> &lt;/mixed&gt;</pre><p>is transformed into</p><pre class="programlisting">&lt;interleave&gt; <em class="replaceable"><code>p</code></em> &lt;text/&gt; &lt;/interleave&gt;</pre></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e781"></a>4.14.&nbsp;<code class="literal">optional</code> element</h3></div></div><p>An <code class="literal">optional</code> element is transformed into
a <code class="literal">choice</code> element with one child being the child of the <code class="literal">optional</code> element and the other child being <code class="literal">empty</code>:</p><pre class="programlisting">&lt;optional&gt; <em class="replaceable"><code>p</code></em> &lt;/optional&gt;</pre><p>is transformed into</p><pre class="programlisting">&lt;choice&gt; <em class="replaceable"><code>p</code></em> &lt;empty/&gt; &lt;/choice&gt;</pre></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e804"></a>4.15.&nbsp;<code class="literal">zeroOrMore</code> element</h3></div></div><p>A <code class="literal">zeroOrMore</code> element is transformed into a <code class="literal">choice</code> element with one child being an &lt;oneOrMore&gt; <em class="replaceable"><code>p</code></em> &lt;/oneOrMore&gt; element and the other child being an <code class="literal">empty</code> element, where <em class="replaceable"><code>p</code></em> is the child of the <code class="literal">literal&gt;zeroOrMore</code> element:</p><pre class="programlisting">&lt;zeroOrMore&gt; <em class="replaceable"><code>p</code></em> &lt;/zeroOrMore&gt;</pre><p>is transformed into</p><pre class="programlisting">&lt;choice&gt; &lt;oneOrMore&gt; <em class="replaceable"><code>p</code></em> &lt;/oneOrMore&gt; &lt;empty/&gt; &lt;/choice&gt;</pre></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="constraints"></a>4.16.&nbsp;Constraints</h3></div></div><p>In this rule, no transformation is performed, but various
constraints are checked.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The constraints in this section, unlike the constraints
specified in <a class="xref" href="#restriction" title="7.&nbsp;Restrictions">Section&nbsp;7, &#x201c;Restrictions&#x201d;</a>, can be checked without
resolving any <code class="literal">ref</code> elements, and are accordingly
applied even to patterns that will disappear during later stages of
simplification because they are not reachable (see <a class="xref" href="#define-ref" title="4.19.&nbsp;define and ref elements">Section&nbsp;4.19, &#x201c;<code class="literal">define</code> and <code class="literal">ref</code> elements&#x201d;</a>) or because of <code class="literal">notAllowed</code>
(see <a class="xref" href="#notAllowed" title="4.20.&nbsp;notAllowed element">Section&nbsp;4.20, &#x201c;<code class="literal">notAllowed</code> element&#x201d;</a>).</p></div><p>An <code class="literal">except</code> element that is a child of an
<code class="literal">anyName</code> element must not have any
<code class="literal">anyName</code> descendant elements. An
<code class="literal">except</code> element that is a child of an
<code class="literal">nsName</code> element must not have any
<code class="literal">nsName</code> or <code class="literal">anyName</code> descendant
elements.</p><p>A <code class="literal">name</code> element that occurs as the first child
of an <code class="literal">attribute</code> element or as the descendant of the
first child of an <code class="literal">attribute</code> element and that has an
<code class="literal">ns</code> attribute with value equal to the empty string
must not have content equal to <code class="literal">xmlns</code>.</p><p>A <code class="literal">name</code> or <code class="literal">nsName</code> element
that occurs as the first child of an <code class="literal">attribute</code>
element or as the descendant of the first child of an
<code class="literal">attribute</code> element must not have an
<code class="literal">ns</code> attribute with value
<code class="literal">http://www.w3.org/2000/xmlns</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <a class="xref" href="#infoset">[<abbr class="abbrev">XML Infoset</abbr>]</a> defines the namespace URI of
namespace declaration attributes to be
<code class="literal">http://www.w3.org/2000/xmlns</code>.</p></div><p>A <code class="literal">data</code> or <code class="literal">value</code> element
must be correct in its use of datatypes. Specifically, the
<code class="literal">type</code> attribute must identify a datatype within the
datatype library identified by the value of the
<code class="literal">datatypeLibrary</code> attribute.  For a
<code class="literal">data</code> element, the parameter list must be one that
is allowed by the datatype (see <a class="xref" href="#data-pattern" title="6.2.8.&nbsp;data and value pattern">Section&nbsp;6.2.8, &#x201c;<code class="literal">data</code> and <code class="literal">value</code> pattern&#x201d;</a>).</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e914"></a>4.17.&nbsp;<code class="literal">combine</code> attribute</h3></div></div><p>For each <code class="literal">grammar</code> element, all
<code class="literal">define</code> elements with the same name are combined
together.  For any name, there must not be more than one
<code class="literal">define</code> element with that name that does not have a
<code class="literal">combine</code> attribute.  For any name, if there is a
<code class="literal">define</code> element with that name that has a
<code class="literal">combine</code> attribute with the value
<code class="literal">choice</code>, then there must not also be a
<code class="literal">define</code> element with that name that has a
<code class="literal">combine</code> attribute with the value
<code class="literal">interleave</code>. Thus, for any name, if there is more
than one <code class="literal">define</code> element with that name, then there
is a unique value for the <code class="literal">combine</code> attribute for
that name.  After determining this unique value, the
<code class="literal">combine</code> attributes are removed.  A pair of
definitions</p><pre class="programlisting">&lt;define name="<em class="replaceable"><code>n</code></em>"&gt;
  <em class="replaceable"><code>p1</code></em>
&lt;/define&gt;
&lt;define name="<em class="replaceable"><code>n</code></em>"&gt;
  <em class="replaceable"><code>p2</code></em>
&lt;/define&gt;</pre><p>is combined into</p><pre class="programlisting">&lt;define name="<em class="replaceable"><code>n</code></em>"&gt;
  &lt;<em class="replaceable"><code>c</code></em>&gt;
    <em class="replaceable"><code>p1</code></em>
    <em class="replaceable"><code>p2</code></em>
  &lt;/<em class="replaceable"><code>c</code></em>&gt;
&lt;/define&gt;</pre><p>where <em class="replaceable"><code>c</code></em> is the value of the
<code class="literal">combine</code> attribute. Pairs of definitions are
combined until there is exactly one <code class="literal">define</code> element
for each name.</p><p>Similarly, for each <code class="literal">grammar</code> element all
<code class="literal">start</code> elements are combined together.  There must
not be more than one <code class="literal">start</code> element that does not
have a <code class="literal">combine</code> attribute.  If there is a
<code class="literal">start</code> element that has a <code class="literal">combine</code>
attribute with the value <code class="literal">choice</code>, there must not
also be a <code class="literal">start</code> element that has a
<code class="literal">combine</code> attribute with the value
<code class="literal">interleave</code>.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e1002"></a>4.18.&nbsp;<code class="literal">grammar</code> element</h3></div></div><p>In this rule, the schema is transformed so that its top-level
element is <code class="literal">grammar</code> and so that it has no other
<code class="literal">grammar</code> elements.</p><p>Define the <em class="firstterm">in-scope grammar</em> for an
element to be the nearest ancestor <code class="literal">grammar</code> element.  A
<code class="literal">ref</code> element <em class="firstterm">refers to</em> a
<code class="literal">define</code> element if the value of their
<code class="literal">name</code> attributes is the same and their in-scope
grammars are the same.  A <code class="literal">parentRef</code> element
<em class="firstterm">refers to</em> a <code class="literal">define</code> element
if the value of their <code class="literal">name</code> attributes is the same
and the in-scope grammar of the in-scope grammar of the
<code class="literal">parentRef</code> element is the same as the in-scope
grammar of the <code class="literal">define</code> element. Every
<code class="literal">ref</code> or <code class="literal">parentRef</code> element must
refer to a <code class="literal">define</code> element.  A
<code class="literal">grammar</code> must have a <code class="literal">start</code> child
element.</p><p>First, transform the top-level pattern
<em class="replaceable"><code>p</code></em> into
<code class="literal">&lt;grammar&gt;&lt;start&gt;<em class="replaceable"><code>p</code></em>&lt;/start&gt;&lt;/grammar&gt;</code>.
Next, rename <code class="literal">define</code> elements so that no two
<code class="literal">define</code> elements anywhere in the schema have the
same name.  To rename a <code class="literal">define</code> element, change the
value of its <code class="literal">name</code> attribute and change the value of
the <code class="literal">name</code> attribute of all <code class="literal">ref</code>
and <code class="literal">parentRef</code> elements that refer to that
<code class="literal">define</code> element. Next, move all
<code class="literal">define</code> elements to be children of the top-level
<code class="literal">grammar</code> element, replace each nested
<code class="literal">grammar</code> element by the child of its
<code class="literal">start</code> element and rename each
<code class="literal">parentRef</code> element to <code class="literal">ref</code>.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="define-ref"></a>4.19.&nbsp;<code class="literal">define</code> and <code class="literal">ref</code> elements</h3></div></div><p>In this rule, the grammar is transformed so that every
<code class="literal">element</code> element is the child of a
<code class="literal">define</code> element, and the child of every
<code class="literal">define</code> element is an <code class="literal">element</code>
element.</p><p>First, remove any <code class="literal">define</code> element that is not
<em class="firstterm">reachable</em>.  A <code class="literal">define</code> element
is reachable if there is reachable <code class="literal">ref</code> element
referring to it.  A <code class="literal">ref</code> element is reachable if it
is the descendant of the <code class="literal">start</code> element or of a
reachable <code class="literal">define</code> element. Now, for
each <code class="literal">element</code> element that is not the child of a
<code class="literal">define</code> element, add a <code class="literal">define</code>
element to the <code class="literal">grammar</code> element, and replace the
<code class="literal">element</code> element by a <code class="literal">ref</code> element
referring to the added <code class="literal">define</code> element. The value of
the <code class="literal">name</code> attribute of the added
<code class="literal">define</code> element must be different from value of the
<code class="literal">name</code> attribute of all other
<code class="literal">define</code> elements. The child of the added
<code class="literal">define</code> element is the <code class="literal">element</code>
element.</p><p>Define a <code class="literal">ref</code> element to be
<em class="firstterm">expandable</em> if it refers to a
<code class="literal">define</code> element whose child is not an
<code class="literal">element</code> element.  For each <code class="literal">ref</code>
element that is expandable and is a descendant of a
<code class="literal">start</code> element or an <code class="literal">element</code>
element, expand it by replacing the <code class="literal">ref</code> element by
the child of the <code class="literal">define</code> element to which it refers and
then recursively expanding any expandable <code class="literal">ref</code>
elements in this replacement.  This must not result in a loop.
In other words expanding the replacement of a
<code class="literal">ref</code> element having a <code class="literal">name</code> with
value <em class="replaceable"><code>n</code></em> must not require the expansion of
<code class="literal">ref</code> element also having a <code class="literal">name</code>
with value <em class="replaceable"><code>n</code></em>.  Finally, remove any
<code class="literal">define</code> element whose child is not an
<code class="literal">element</code> element.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="notAllowed"></a>4.20.&nbsp;<code class="literal">notAllowed</code> element</h3></div></div><p>In this rule, the grammar is transformed so that a
<code class="literal">notAllowed</code> element occurs only as the child of
a <code class="literal">start</code> or <code class="literal">element</code> element.  An
<code class="literal">attribute</code>, <code class="literal">list</code>,
<code class="literal">group</code>, <code class="literal">interleave</code>,
or <code class="literal">oneOrMore</code> element that has a
<code class="literal">notAllowed</code> child element is transformed into a
<code class="literal">notAllowed</code> element.  A <code class="literal">choice</code>
element that has two <code class="literal">notAllowed</code> child elements is
transformed into a <code class="literal">notAllowed</code> element.  A
<code class="literal">choice</code> element that has one
<code class="literal">notAllowed</code> child element is transformed into its
other child element. An <code class="literal">except</code> element that has a
<code class="literal">notAllowed</code> child element is removed.
The preceding transformations are applied
repeatedly until none of them is applicable any more.
Any <code class="literal">define</code> element that is no longer reachable
is removed.</p></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e1237"></a>4.21.&nbsp;<code class="literal">empty</code> element</h3></div></div><p>In this rule, the grammar is transformed so that an
<code class="literal">empty</code> element does not occur as a child of a
<code class="literal">group</code>, <code class="literal">interleave</code>, or
<code class="literal">oneOrMore</code> element or as the second child of
a <code class="literal">choice</code> element. A <code class="literal">group</code>,
<code class="literal">interleave</code> or <code class="literal">choice</code> element
that has two <code class="literal">empty</code> child elements is transformed
into an <code class="literal">empty</code> element.  A <code class="literal">group</code>
or <code class="literal">interleave</code> element that has one
<code class="literal">empty</code> child element is transformed into its other
child element.  A <code class="literal">choice</code> element whose
second child element is an <code class="literal">empty</code> element is
transformed by interchanging its two child elements.  A
<code class="literal">oneOrMore</code> element that has an
<code class="literal">empty</code> child element is transformed into an
<code class="literal">empty</code> element. The preceding transformations are applied
repeatedly until none of them is applicable any more.</p></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="simple-syntax"></a>5.&nbsp;Simple syntax</h2></div></div><p>After applying all the rules in <a class="xref" href="#simplification" title="4.&nbsp;Simplification">Section&nbsp;4, &#x201c;Simplification&#x201d;</a>, the schema will match the following
grammar:</p><html><head><title></title><link rel="stylesheet" type="text/css" href="tr.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table><tr valign="baseline"><td>grammar</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;grammar</code><code>&gt; </code><code>&lt;start</code><code>&gt; </code><i>top</i><code> &lt;/start&gt;</code> <i>define</i>*<code> &lt;/grammar&gt;</code></td></tr><tr valign="baseline"><td>define</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;define</code> <code>name="</code><i>NCName</i><code>"</code><code>&gt; </code><code>&lt;element</code><code>&gt; </code><i>nameClass</i> <i>top</i><code> &lt;/element&gt;</code><code> &lt;/define&gt;</code></td></tr><tr valign="baseline"><td>top</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;notAllowed</code><code>/&gt;</code><br>| <i>pattern</i></td></tr><tr valign="baseline"><td>pattern</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;empty</code><code>/&gt;</code><br>| <i>nonEmptyPattern</i></td></tr><tr valign="baseline"><td>nonEmptyPattern</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;text</code><code>/&gt;</code><br>| <code>&lt;data</code> <code>type="</code><i>NCName</i><code>"</code> <code>datatypeLibrary="</code><i>anyURI</i><code>"</code><code>&gt; </code><i>param</i>* [<i>exceptPattern</i>]<code> &lt;/data&gt;</code><br>| <code>&lt;value</code> <code>datatypeLibrary="</code><i>anyURI</i><code>"</code> <code>type="</code><i>NCName</i><code>"</code> <code>ns="</code><i>string</i><code>"</code><code>&gt; </code><i>string</i><code> &lt;/value&gt;</code><br>| <code>&lt;list</code><code>&gt; </code><i>pattern</i><code> &lt;/list&gt;</code><br>| <code>&lt;attribute</code><code>&gt; </code><i>nameClass</i> <i>pattern</i><code> &lt;/attribute&gt;</code><br>| <code>&lt;ref</code> <code>name="</code><i>NCName</i><code>"</code><code>/&gt;</code><br>| <code>&lt;oneOrMore</code><code>&gt; </code><i>nonEmptyPattern</i><code> &lt;/oneOrMore&gt;</code><br>| <code>&lt;choice</code><code>&gt; </code><i>pattern</i> <i>nonEmptyPattern</i><code> &lt;/choice&gt;</code><br>| <code>&lt;group</code><code>&gt; </code><i>nonEmptyPattern</i> <i>nonEmptyPattern</i><code> &lt;/group&gt;</code><br>| <code>&lt;interleave</code><code>&gt; </code><i>nonEmptyPattern</i> <i>nonEmptyPattern</i><code> &lt;/interleave&gt;</code></td></tr><tr valign="baseline"><td>param</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;param</code> <code>name="</code><i>NCName</i><code>"</code><code>&gt; </code><i>string</i><code> &lt;/param&gt;</code></td></tr><tr valign="baseline"><td>exceptPattern</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;except</code><code>&gt; </code><i>pattern</i><code> &lt;/except&gt;</code></td></tr><tr valign="baseline"><td>nameClass</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;anyName</code><code>&gt; </code>[<i>exceptNameClass</i>]<code> &lt;/anyName&gt;</code><br>| <code>&lt;nsName</code> <code>ns="</code><i>string</i><code>"</code><code>&gt; </code>[<i>exceptNameClass</i>]<code> &lt;/nsName&gt;</code><br>| <code>&lt;name</code> <code>ns="</code><i>string</i><code>"</code><code>&gt; </code><i>NCName</i><code> &lt;/name&gt;</code><br>| <code>&lt;choice</code><code>&gt; </code><i>nameClass</i> <i>nameClass</i><code> &lt;/choice&gt;</code></td></tr><tr valign="baseline"><td>exceptNameClass</td><td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td><td><code>&lt;except</code><code>&gt; </code><i>nameClass</i><code> &lt;/except&gt;</code></td></tr></table></body></html><p>With this grammar, no elements or attributes are allowed other
than those explicitly shown.</p><div class="section"><div class="titlepage"><div><h3 class="title"><a name="simple-syntax-example"></a>5.1.&nbsp;Example</h3></div></div><p>The following is an example of how the schema in <a class="xref" href="#full-syntax-example" title="3.1.&nbsp;Example">Section&nbsp;3.1, &#x201c;Example&#x201d;</a> can be transformed into the simple
syntax:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    &lt;ref name="foo.element"/&gt;
  &lt;/start&gt;

  &lt;define name="foo.element"&gt;
    &lt;element&gt;
      &lt;name ns=""&gt;foo&lt;/name&gt;
      &lt;group&gt;
        &lt;ref name="bar1.element"/&gt;
        &lt;ref name="bar2.element"/&gt;
      &lt;/group&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="bar1.element"&gt;
    &lt;element&gt;
      &lt;name ns="http://www.example.com/n1"&gt;bar1&lt;/name&gt;
      &lt;empty/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="bar2.element"&gt;
    &lt;element&gt;
      &lt;name ns="http://www.example.com/n2"&gt;bar2&lt;/name&gt;
      &lt;empty/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Strictly speaking, the result of simplification is an
instance of the data model rather than an XML document.  For
convenience, we use an XML document to represent an instance of the
data model.</p></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="semantics"></a>6.&nbsp;Semantics</h2></div></div><p>In this section, we define the semantics of a correct RELAX NG
schema that has been transformed into the simple syntax.  The
semantics of a RELAX NG schema consist of a specification of what XML
documents are valid with respect to that schema.  The semantics are
described formally.  The formalism uses axioms and inference rules.
Axioms are propositions that are provable unconditionally.  An
inference rule consists of one or more antecedents and exactly one
consequent.  An antecedent is either positive or negative.  If all the
positive antecedents of an inference rule are provable and none of the
negative antecedents are provable, then the consequent of the
inference rule is provable. An XML document is valid with respect to a
RELAX NG schema if and only if the proposition that it is valid is
provable in the formalism specified in this section.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This kind of formalism is similar to a proof system.
However, a traditional proof system only has positive
antecedents.</p></div><p>The notation for inference rules separates the antecedents from
the consequent by a horizontal line: the antecedents are above the
line; the consequent is below the line.  If an antecedent is of the
form not(<em class="replaceable"><code>p</code></em>), then it is a negative
antecedent; otherwise, it is a positive antecedent.  Both axioms and
inferences
rules may use variables.  A variable has a name and optionally a
subscript.  The name of a variable is italicized.  Each variable has a
range that is determined by its name.  Axioms and inference rules are
implicitly universally quantified over the variables they contain.  We
explain this further below.</p><p>The possibility that an inference rule or axiom may contain more
than one occurrence of a particular variable requires that an identity
relation be defined on each kind of object over which a variable can
range.  The identity relation for all kinds of object is value-based.
Two objects of a particular kind are identical if the constituents of
the objects are identical.  For example, two attributes are considered
the same if they have the same name and the same value. Two characters
are identical if their Unicode character codes are the same.</p><div class="section"><div class="titlepage"><div><h3 class="title"><a name="name-classes"></a>6.1.&nbsp;Name classes</h3></div></div><p>The main semantic concept for name classes is that of a name
belonging to a name class. A name class is an element that matches the
production nameClass. A name is as defined in <a class="xref" href="#data-model" title="2.&nbsp;Data model">Section&nbsp;2, &#x201c;Data model&#x201d;</a>: it consists of a namespace URI and a local
name.</p><p>We use the following notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>n</i></span></dt><dd><a name="d61e1320"></a>is a variable
that ranges over names</dd><dt><span class="term"><i>nc</i></span></dt><dd><a name="d61e1325"></a>ranges over name classes</dd><dt><span class="term"><i>n</i> in <i>nc</i></span></dt><dd><a name="d61e1335"></a>
    
asserts that name <i>n</i> is a member of name class <i>nc</i>

</dd></dl></div><p>We are now ready for our first axiom, which is called "anyName
1":</p>
  <table cellspacing="20"><tr valign="center"><td>(anyName 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><i>n</i> in <code>&lt;anyName</code><code>/&gt;</code></td></tr></table></td></tr></table>
<p>This says for any name <i>n</i>, <i>n</i> belongs to the name class <code>&lt;anyName</code><code>/&gt;</code>,
in other words <code>&lt;anyName</code><code>/&gt;</code> matches any name. Note the
effect of the implicit universal quantification over the variables in
the axiom: this is what makes the axiom apply for any name <i>n</i>.</p><p>Our first inference rule is almost as simple:</p>
  <table cellspacing="20"><tr valign="center"><td>(anyName 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>not(<i>n</i> in <i>nc</i>)</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>n</i> in <code>&lt;anyName</code><code>&gt;</code> <code>&lt;except</code><code>&gt;</code> <i>nc</i> <code>&lt;/except&gt;</code> <code>&lt;/anyName&gt;</code></td></tr></table></td></tr></table>

<p>This says that for any name <i>n</i>
and for any name class 	<i>nc</i>,
if <i>n</i> does not belong to <i>nc</i>,
then <i>n</i> belongs to 
      <code>&lt;anyName</code><code>&gt;</code> <code>&lt;except</code><code>&gt;</code> <i>nc</i> <code>&lt;/except&gt;</code> <code>&lt;/anyName&gt;</code>. In other words,       <code>&lt;anyName</code><code>&gt;</code> <code>&lt;except</code><code>&gt;</code> <i>nc</i> <code>&lt;/except&gt;</code> <code>&lt;/anyName&gt;</code> matches any name that does not match <i>nc</i>.</p><p>We now need the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>ln</i></span></dt><dd><a name="d61e1433"></a>ranges over local names; a local name is a string that
matches the NCName production of <a class="xref" href="#xml-names">[<abbr class="abbrev">XML Namespaces</abbr>]</a>, that is,
a name with no colons</dd><dt><span class="term"><i>u</i></span></dt><dd><a name="d61e1441"></a>ranges over URIs</dd><dt><span class="term">
  name( <i>u</i>, <i>ln</i> )
</span></dt><dd><a name="d61e1453"></a>constructs a name with URI <i>u</i> and local
name <i>ln</i></dd></dl></div><p>The remaining axioms and inference rules for name classes are as
follows:</p>

  <table cellspacing="20"><tr valign="center"><td>(nsName 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">name( <i>u</i>, <i>ln</i> ) in <code>&lt;nsName</code><code> ns="</code><i>u</i><code>"</code><code>/&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(nsName 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>not(name( <i>u</i>, <i>ln</i> ) in <i>nc</i>)</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1">name( <i>u</i>, <i>ln</i> ) in <code>&lt;nsName</code><code> ns="</code><i>u</i><code>"</code><code>&gt;</code> <code>&lt;except</code><code>&gt;</code> <i>nc</i> <code>&lt;/except&gt;</code> <code>&lt;/nsName&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(name)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">name( <i>u</i>, <i>ln</i> ) in <code>&lt;name</code><code> ns="</code><i>u</i><code>"</code><code>&gt;</code> <i>ln</i> <code>&lt;/name&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(name choice 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>n</i> in <i>nc</i><sub>1</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>n</i> in <code>&lt;choice</code><code>&gt;</code> <i>nc</i><sub>1</sub> <i>nc</i><sub>2</sub> <code>&lt;/choice&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(name choice 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>n</i> in <i>nc</i><sub>2</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>n</i> in <code>&lt;choice</code><code>&gt;</code> <i>nc</i><sub>1</sub> <i>nc</i><sub>2</sub> <code>&lt;/choice&gt;</code></td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e1591"></a>6.2.&nbsp;Patterns</h3></div></div><p>The axioms and inference rules for patterns use the following
notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>cx</i></span></dt><dd><a name="d61e1598"></a>ranges
over contexts (as defined in <a class="xref" href="#data-model" title="2.&nbsp;Data model">Section&nbsp;2, &#x201c;Data model&#x201d;</a>)</dd><dt><span class="term"><i>a</i></span></dt><dd><a name="d61e1606"></a>ranges over
sets of attributes; a set with a single member
is considered the same as that member</dd><dt><span class="term"><i>m</i></span></dt><dd><a name="d61e1611"></a>ranges over sequences of
elements and strings; a sequence with a single member is considered
the same as that member; the sequences ranged over by <i>m</i> may contain consecutive strings and may contain strings
that are empty; thus, there are sequences ranged over by <i>m</i> that cannot occur as the children of an
element</dd><dt><span class="term"><i>p</i></span></dt><dd><a name="d61e1621"></a>ranges
over patterns (elements matching the pattern
production)</dd><dt><span class="term"><i>cx</i> |- <i>a</i>; <i>m</i> =~ <i>p</i></span></dt><dd><a name="d61e1635"></a>
    
asserts that with respect to context <i>cx</i>, the
attributes <i>a</i> and the sequence of elements and
strings <i>m</i> matches the pattern <i>p</i></dd></dl></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="choice-pattern"></a>6.2.1.&nbsp;<code class="literal">choice</code> pattern</h4></div></div><p>The semantics of the <code class="literal">choice</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(choice 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; <i>m</i> =~ <i>p</i><sub>1</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; <i>m</i> =~ <code>&lt;choice</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/choice&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(choice 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; <i>m</i> =~ <i>p</i><sub>2</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; <i>m</i> =~ <code>&lt;choice</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/choice&gt;</code></td></tr></table></td></tr></table>


</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e1715"></a>6.2.2.&nbsp;<code class="literal">group</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>m</i><sub>1</sub>, <i>m</i><sub>2</sub></span></dt><dd><a name="d61e1729"></a>represents the concatenation of the sequences <i>m</i><sub>1</sub> and <i>m</i><sub>2</sub>

</dd><dt><span class="term"><i>a</i><sub>1</sub> + <i>a</i><sub>2</sub></span></dt><dd><a name="d61e1744"></a>represents the union of <i>a</i><sub>1</sub>
and <i>a</i><sub>2</sub></dd></dl></div><p>The semantics of the <code class="literal">group</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(group)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i><sub>1</sub>; <i>m</i><sub>1</sub> =~ <i>p</i><sub>1</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>cx</i> |- <i>a</i><sub>2</sub>; <i>m</i><sub>2</sub> =~ <i>p</i><sub>2</sub></td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2"><i>cx</i> |- <i>a</i><sub>1</sub> + <i>a</i><sub>2</sub>; <i>m</i><sub>1</sub>, <i>m</i><sub>2</sub> =~ <code>&lt;group</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/group&gt;</code></td></tr></table></td></tr></table>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The restriction in <a class="xref" href="#attribute-restrictions" title="7.3.&nbsp;Restrictions on attributes">Section&nbsp;7.3, &#x201c;Restrictions on attributes&#x201d;</a>
ensures that the set of attributes constructed in the consequent will
not have multiple attributes with the same name.</p></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="empty-pattern"></a>6.2.3.&nbsp;<code class="literal">empty</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">( )</span></dt><dd><a name="d61e1821"></a>represents an empty sequence</dd><dt><span class="term">{ }</span></dt><dd><a name="d61e1826"></a>represents an empty set</dd></dl></div><p>The semantics of the <code class="literal">empty</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(empty)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><i>cx</i> |- { }; ( ) =~ <code>&lt;empty</code><code>/&gt;</code></td></tr></table></td></tr></table>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="text-pattern"></a>6.2.4.&nbsp;<code class="literal">text</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>s</i></span></dt><dd><a name="d61e1862"></a>ranges
over strings</dd></dl></div><p>The semantics of the <code class="literal">text</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(text 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><i>cx</i> |- { }; ( ) =~ <code>&lt;text</code><code>/&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(text 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- { }; <i>m</i> =~ <code>&lt;text</code><code>/&gt;</code></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- { }; <i>m</i>, <i>s</i> =~ <code>&lt;text</code><code>/&gt;</code></td></tr></table></td></tr></table>

<p>The effect of the above rule is that a <code class="literal">text</code>
element matches zero or more strings.</p></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e1933"></a>6.2.5.&nbsp;<code class="literal">oneOrMore</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">disjoint(<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>)</span></dt><dd><a name="d61e1947"></a>
asserts that there is no name that is
the name of both an attribute in <i>a</i><sub>1</sub>
and of an attribute in <i>a</i><sub>2</sub>
</dd></dl></div><p>The semantics of the <code class="literal">oneOrMore</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(oneOrMore 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; <i>m</i> =~ <i>p</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; <i>m</i> =~ <code>&lt;oneOrMore</code><code>&gt;</code> <i>p</i> <code>&lt;/oneOrMore&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(oneOrMore 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i><sub>1</sub>; <i>m</i><sub>1</sub> =~ <i>p</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>cx</i> |- <i>a</i><sub>2</sub>; <i>m</i><sub>2</sub> =~ <code>&lt;oneOrMore</code><code>&gt;</code> <i>p</i> <code>&lt;/oneOrMore&gt;</code></td><td>&nbsp;&nbsp;&nbsp;&nbsp;disjoint(<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>)</td></tr><tr><td colspan="3"><hr noshade></td></tr><tr align="center"><td colspan="3"><i>cx</i> |- <i>a</i><sub>1</sub> + <i>a</i><sub>2</sub>; <i>m</i><sub>1</sub>, <i>m</i><sub>2</sub> =~ <code>&lt;oneOrMore</code><code>&gt;</code> <i>p</i> <code>&lt;/oneOrMore&gt;</code></td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e2047"></a>6.2.6.&nbsp;<code class="literal">interleave</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>m</i><sub>1</sub> interleaves <i>m</i><sub>2</sub>; <i>m</i><sub>3</sub></span></dt><dd><a name="d61e2063"></a>
    
asserts that <i>m</i><sub>1</sub>
is an interleaving of <i>m</i><sub>2</sub>
and <i>m</i><sub>3</sub>
</dd></dl></div><p>The semantics of interleaving are defined by the following rules.</p>
  <table cellspacing="20"><tr valign="center"><td>(interleaves 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">( ) interleaves ( ); ( )</td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(interleaves 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>m</i><sub>1</sub> interleaves <i>m</i><sub>2</sub>; <i>m</i><sub>3</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>m</i><sub>4</sub>, <i>m</i><sub>1</sub> interleaves <i>m</i><sub>4</sub>, <i>m</i><sub>2</sub>; <i>m</i><sub>3</sub></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(interleaves 3)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>m</i><sub>1</sub> interleaves <i>m</i><sub>2</sub>; <i>m</i><sub>3</sub></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>m</i><sub>4</sub>, <i>m</i><sub>1</sub> interleaves <i>m</i><sub>2</sub>; <i>m</i><sub>4</sub>, <i>m</i><sub>3</sub></td></tr></table></td></tr></table>

<p>For example, the interleavings of
<code class="literal">&lt;a/&gt;&lt;a/&gt;</code> and
<code class="literal">&lt;b/&gt;</code> are
<code class="literal">&lt;a/&gt;&lt;a/&gt;&lt;b/&gt;</code>,
<code class="literal">&lt;a/&gt;&lt;b/&gt;&lt;a/&gt;</code>, and
<code class="literal">&lt;b/&gt;&lt;a/&gt;&lt;a/&gt;</code>.</p><p>The semantics of the <code class="literal">interleave</code> pattern are
as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(interleave)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i><sub>1</sub>; <i>m</i><sub>1</sub> =~ <i>p</i><sub>1</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>cx</i> |- <i>a</i><sub>2</sub>; <i>m</i><sub>2</sub> =~ <i>p</i><sub>2</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>m</i><sub>3</sub> interleaves <i>m</i><sub>1</sub>; <i>m</i><sub>2</sub></td></tr><tr><td colspan="3"><hr noshade></td></tr><tr align="center"><td colspan="3"><i>cx</i> |- <i>a</i><sub>1</sub> + <i>a</i><sub>2</sub>; <i>m</i><sub>3</sub> =~ <code>&lt;interleave</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/interleave&gt;</code></td></tr></table></td></tr></table>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The restriction in <a class="xref" href="#attribute-restrictions" title="7.3.&nbsp;Restrictions on attributes">Section&nbsp;7.3, &#x201c;Restrictions on attributes&#x201d;</a>
ensures that the set of attributes constructed in the consequent will
not have multiple attributes with the same name.</p></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="element-pattern"></a>6.2.7.&nbsp;<code class="literal">element</code> and <code class="literal">attribute</code> pattern</h4></div></div><p>The value of an attribute is always a single string, which may
be empty.  Thus, the empty sequence is not a possible attribute value.
On the hand, the children of an element can be an empty sequence and
cannot consist of an empty string.  In order to ensure that validation
handles attributes and elements consistently, we introduce a variant
of matching called <em class="firstterm">weak matching</em>.  Weak
matching is used when matching the pattern for the value of an
attribute or for the attributes and children of an element.  We use
the following notation to define weak matching.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code>""</code></span></dt><dd><a name="d61e2241"></a>represents an empty
string</dd><dt><span class="term"><i>ws</i></span></dt><dd><a name="d61e2246"></a>ranges over the empty
sequence and strings that consist entirely of
whitespace</dd><dt><span class="term"><i>cx</i> |- <i>a</i>; <i>m</i> =~<sub>weak</sub> <i>p</i></span></dt><dd><a name="d61e2260"></a>
    
asserts that with respect to context <i>cx</i>, the
attributes <i>a</i> and the sequence of elements and
strings <i>m</i> weakly matches the pattern <i>p</i></dd></dl></div><p>The semantics of weak matching are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(weak match 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; <i>m</i> =~ <i>p</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; <i>m</i> =~<sub>weak</sub> <i>p</i></td></tr></table></td></tr></table>
  <table cellspacing="20"><tr valign="center"><td>(weak match 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; ( ) =~ <i>p</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; <i>ws</i> =~<sub>weak</sub> <i>p</i></td></tr></table></td></tr></table>
  <table cellspacing="20"><tr valign="center"><td>(weak match 3)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- <i>a</i>; <code>""</code> =~ <i>p</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- <i>a</i>; ( ) =~<sub>weak</sub> <i>p</i></td></tr></table></td></tr></table>
<p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">attribute( <i>n</i>, <i>s</i> )</span></dt><dd><a name="d61e2358"></a>
      
constructs an attribute with name <i>n</i>
and value <i>s</i>
</dd><dt><span class="term">element( <i>n</i>, <i>cx</i>, <i>a</i>, <i>m</i> )</span></dt><dd><a name="d61e2377"></a>
      
constructs an element with name <i>n</i>,
context <i>cx</i>,
attributes <i>a</i>
and mixed sequence <i>m</i> as children
</dd><dt><span class="term">okAsChildren(<i>m</i>)</span></dt><dd><a name="d61e2394"></a>
    
asserts that the mixed sequence <i>m</i> can occur as
the children of an element: it does not contain any member that is an
empty string, nor does it contain two consecutive members that are
both strings</dd><dt><span class="term">deref(<i>ln</i>) = <code>&lt;element&gt; </code><i>nc</i> <i>p</i><code> &lt;/element&gt;</code></span></dt><dd><a name="d61e2409"></a>
    
asserts that the grammar contains
<code>&lt;define</code><code> name="</code><i>ln</i><code>"</code><code>&gt;</code> <code>&lt;element</code><code>&gt;</code> <i>nc</i> <i>p</i> <code>&lt;/element&gt;</code> <code>&lt;/define&gt;</code>
</dd></dl></div><p>The semantics of the <code class="literal">attribute</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(attribute)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- { }; <i>s</i> =~<sub>weak</sub> <i>p</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>n</i> in <i>nc</i></td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2"><i>cx</i> |- attribute( <i>n</i>, <i>s</i> ); ( ) =~ <code>&lt;attribute</code><code>&gt;</code> <i>nc</i> <i>p</i> <code>&lt;/attribute&gt;</code></td></tr></table></td></tr></table>

<p>The semantics of the <code class="literal">element</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(element)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i><sub>1</sub> |- <i>a</i>; <i>m</i> =~<sub>weak</sub> <i>p</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>n</i> in <i>nc</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;okAsChildren(<i>m</i>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;deref(<i>ln</i>) = <code>&lt;element&gt; </code><i>nc</i> <i>p</i><code> &lt;/element&gt;</code></td></tr><tr><td colspan="4"><hr noshade></td></tr><tr align="center"><td colspan="4"><i>cx</i><sub>2</sub> |- { }; <i>ws</i><sub>1</sub>, element( <i>n</i>, <i>cx</i><sub>1</sub>, <i>a</i>, <i>m</i> ), <i>ws</i><sub>2</sub> =~ <code>&lt;ref</code><code> name="</code><i>ln</i><code>"</code><code>/&gt;</code></td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="data-pattern"></a>6.2.8.&nbsp;<code class="literal">data</code> and <code class="literal">value</code> pattern</h4></div></div><p>RELAX NG relies on datatype libraries to perform datatyping.
A datatype library is identified by a URI.  A datatype within a
datatype library is identified by an NCName.  A datatype library
provides two services.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e2557"></a>It can determine whether a string is a legal
representation of a datatype. This service accepts a list of zero or
more parameters. For example, a string datatype might have a parameter
specifying the length of a string.  The datatype library determines
what parameters are applicable for each datatype.</li><li class="listitem"><a name="d61e2559"></a>It can determine whether two strings represent the
same value of a datatype.  This service does not have any
parameters.</li></ul></div><p>Both services may make use of the context of a string.  For
example, a datatype representing a QName would use the namespace
map.</p><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">datatypeAllows(<i>u</i>, <i>ln</i>, <i>params</i>, <i>s</i>, <i>cx</i>)</span></dt><dd><a name="d61e2578"></a>
    
asserts that in the datatype library identified by URI <i>u</i>, the string <i>s</i> interpreted with
context <i>cx</i> is a legal
value of datatype <i>ln</i> with parameters <i>params</i></dd><dt><span class="term">datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>2</sub>, <i>cx</i><sub>2</sub>)</span></dt><dd><a name="d61e2607"></a>
    
asserts that in the datatype library identified by URI <i>u</i>, string <i>s</i><sub>1</sub> interpreted with
context <i>cx</i><sub>1</sub> represents the same value of
the datatype <i>ln</i> as the string <i>s</i><sub>2</sub> interpreted in the context of <i>cx</i><sub>2</sub>
</dd><dt><span class="term"><i>params</i></span></dt><dd><a name="d61e2626"></a>ranges over sequences of parameters</dd><dt><span class="term">[<i>cx</i>]</span></dt><dd><a name="d61e2634"></a>
   
within the start-tag of a pattern refers to the context
of the pattern element
</dd><dt><span class="term">
  context( <i>u</i>, <i>cx</i> )
</span></dt><dd><a name="d61e2646"></a>constructs a context which is the same as <i>cx</i>
except that the default namespace is <i>u</i>; if <i>u</i> is the empty string, then there is no default namespace
in the constructed context</dd></dl></div><p>The datatypeEqual function must be reflexive, transitive
and symmetric, that is, the following inference rules must hold:</p>
  <table cellspacing="20"><tr valign="center"><td>(datatypeEqual reflexive)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeAllows(<i>u</i>, <i>ln</i>, <i>params</i>, <i>s</i>, <i>cx</i>)</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1">datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i>, <i>cx</i>, <i>s</i>, <i>cx</i>)</td></tr></table></td></tr></table>
  <table cellspacing="20"><tr valign="center"><td>(datatypeEqual transitive)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>2</sub>, <i>cx</i><sub>2</sub>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>2</sub>, <i>cx</i><sub>3</sub>, <i>s</i><sub>3</sub>, <i>cx</i><sub>3</sub>)</td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2">datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>3</sub>, <i>cx</i><sub>3</sub>)</td></tr></table></td></tr></table>
  <table cellspacing="20"><tr valign="center"><td>(datatypeEqual symmetric)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>2</sub>, <i>cx</i><sub>2</sub>)</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1">datatypeEqual(<i>u</i>, <i>ln</i>, <i>s</i><sub>2</sub>, <i>cx</i><sub>2</sub>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>)</td></tr></table></td></tr></table>
<p>The semantics of the <code class="literal">data</code> and
<code class="literal">value</code> patterns are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(value)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeEqual(<i>u</i><sub>1</sub>, <i>ln</i>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>2</sub>, context( <i>u</i><sub>2</sub>, <i>cx</i><sub>2</sub> ))</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i><sub>1</sub> |- { }; <i>s</i><sub>1</sub> =~ <code>&lt;value</code><code> datatypeLibrary="</code><i>u</i><sub>1</sub><code>"</code><code> type="</code><i>ln</i><code>"</code><code> ns="</code><i>u</i><sub>2</sub><code>"</code><code> </code>[<i>cx</i><sub>2</sub>]<code>&gt;</code> <i>s</i><sub>2</sub> <code>&lt;/value&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(data 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeAllows(<i>u</i>, <i>ln</i>, <i>params</i>, <i>s</i>, <i>cx</i>)</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- { }; <i>s</i> =~ <code>&lt;data</code><code> datatypeLibrary="</code><i>u</i><code>"</code><code> type="</code><i>ln</i><code>"</code><code>&gt;</code> <i>params</i> <code>&lt;/data&gt;</code></td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(data 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>datatypeAllows(<i>u</i>, <i>ln</i>, <i>params</i>, <i>s</i>, <i>cx</i>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not(<i>cx</i> |- <i>a</i>; <i>s</i> =~ <i>p</i>)</td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2"><i>cx</i> |- { }; <i>s</i> =~ <code>&lt;data</code><code> datatypeLibrary="</code><i>u</i><code>"</code><code> type="</code><i>ln</i><code>"</code><code>&gt;</code> <i>params</i> <code>&lt;except</code><code>&gt;</code> <i>p</i> <code>&lt;/except&gt;</code> <code>&lt;/data&gt;</code></td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="built-in-datatype"></a>6.2.9.&nbsp;Built-in datatype library</h4></div></div><p>The empty URI identifies a special built-in datatype library.
This provides two datatypes, <code class="literal">string</code> and
<code class="literal">token</code>.  No parameters are allowed for either of
these datatypes.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
    <i>s</i><sub>1</sub> = <i>s</i><sub>2</sub></span></dt><dd><a name="d61e2975"></a>asserts that <i>s</i><sub>1</sub>
and <i>s</i><sub>2</sub> are identical</dd><dt><span class="term">
      normalizeWhiteSpace( <i>s</i> )
</span></dt><dd><a name="d61e2990"></a>returns the string <i>s</i>,
with leading and trailing whitespace characters removed,
and with each other maximal sequence of whitespace characters
replaced by a single space character </dd></dl></div><p>The semantics of the two built-in datatypes are as
follows:</p>

  <table cellspacing="20"><tr valign="center"><td>(string allows)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">datatypeAllows(<code>""</code>, <code>"string"</code>, ( ), <i>s</i>, <i>cx</i>)</td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(string equal)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">datatypeEqual(<code>""</code>, <code>"string"</code>, <i>s</i>, <i>cx</i><sub>1</sub>, <i>s</i>, <i>cx</i><sub>2</sub>)</td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(token allows)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">datatypeAllows(<code>""</code>, <code>"token"</code>, ( ), <i>s</i>, <i>cx</i>)</td></tr></table></td></tr></table>

  <table cellspacing="20"><tr valign="center"><td>(token equal)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>normalizeWhiteSpace( <i>s</i><sub>1</sub> ) = normalizeWhiteSpace( <i>s</i><sub>2</sub> )</td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1">datatypeEqual(<code>""</code>, <code>"token"</code>, <i>s</i><sub>1</sub>, <i>cx</i><sub>1</sub>, <i>s</i><sub>2</sub>, <i>cx</i><sub>2</sub>)</td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e3081"></a>6.2.10.&nbsp;<code class="literal">list</code> pattern</h4></div></div><p>We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">split( <i>s</i> )</span></dt><dd><a name="d61e3093"></a>
      
returns a sequence of strings one for each whitespace delimited token
of <i>s</i>; each string in the returned sequence will
be non-empty and will not contain any
whitespace</dd></dl></div><p>The semantics of the <code class="literal">list</code> pattern are as follows:</p>
  <table cellspacing="20"><tr valign="center"><td>(list)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>cx</i> |- { }; split( <i>s</i> ) =~ <i>p</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><i>cx</i> |- { }; <i>s</i> =~ <code>&lt;list</code><code>&gt;</code> <i>p</i> <code>&lt;/list&gt;</code></td></tr></table></td></tr></table>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is crucial in the above inference rule that the
sequence that is matched against a pattern can contain consecutive
strings.</p></div></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="validity"></a>6.3.&nbsp;Validity</h3></div></div><p>Now we can define when an element is valid with respect to a
schema.  We use the following additional notation:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><i>e</i></span></dt><dd><a name="d61e3144"></a>ranges over elements</dd><dt><span class="term">valid(<i>e</i>)</span></dt><dd><a name="d61e3152"></a>
    
asserts that the element <i>e</i> is valid with
respect to the grammar</dd><dt><span class="term">start() = <i>p</i></span></dt><dd><a name="d61e3163"></a>
asserts that the grammar contains
<code>&lt;start</code><code>&gt;</code> <i>p</i> <code>&lt;/start&gt;</code></dd></dl></div><p>An element is valid if together with an empty set of attributes
it matches the <code class="literal">start</code> pattern of the grammar.</p>
  <table cellspacing="20"><tr valign="center"><td>(valid)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>start() = <i>p</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>cx</i> |- { }; <i>e</i> =~ <i>p</i></td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2">valid(<i>e</i>)</td></tr></table></td></tr></table>
      

</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="d61e3199"></a>6.4.&nbsp;Example</h3></div></div><p>Let <i>e</i><sub>0</sub> be</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">

element( name( <code>""</code>, <code>"foo"</code> ), <i>cx</i><sub>0</sub>, { }, <i>m</i> )

</div><p>where <i>m</i> is</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>e</i><sub>1</sub>, <i>e</i><sub>2</sub>
</div><p>and <i>e</i><sub>1</sub> is</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  element( name( <code>"http://www.example.com/n1"</code>, <code>"bar1"</code> ), <i>cx</i><sub>1</sub>, { }, ( ) )
</div><p>and <i>e</i><sub>2</sub> is</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  element( name( <code>"http://www.example.com/n2"</code>, <code>"bar2"</code> ), <i>cx</i><sub>2</sub>, { }, ( ) )
</div><p>Assuming appropriate definitions of <i>cx</i><sub>0</sub>, <i>cx</i><sub>1</sub> and <i>cx</i><sub>2</sub>, this represents the document in <a class="xref" href="#data-model-example" title="2.1.&nbsp;Example">Section&nbsp;2.1, &#x201c;Example&#x201d;</a>.</p><p>We now show how <i>e</i><sub>0</sub> can be shown to
be valid with respect to the schema in <a class="xref" href="#simple-syntax-example" title="5.1.&nbsp;Example">Section&nbsp;5.1, &#x201c;Example&#x201d;</a>.  The schema is equivalent to the
following propositions:</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  start() = <code>&lt;ref</code><code> name="</code><code>foo</code><code>"</code><code>/&gt;</code>
</div><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  deref(<code>"foo.element"</code>) = <code>&lt;element&gt; </code><code>&lt;name</code><code> ns="</code><code>"</code><code>&gt;</code> <code>"foo"</code> <code>&lt;/name&gt;</code> <code>&lt;group</code><code>&gt;</code> <code>&lt;ref</code><code> name="</code><code>bar1</code><code>"</code><code>/&gt;</code> <code>&lt;ref</code><code> name="</code><code>bar2</code><code>"</code><code>/&gt;</code> <code>&lt;/group&gt;</code><code> &lt;/element&gt;</code>
</div><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  deref(<code>"bar1.element"</code>) = <code>&lt;element&gt; </code><code>&lt;name</code><code> ns="</code><code>http://www.example.com/n1</code><code>"</code><code>&gt;</code> <code>"bar1"</code> <code>&lt;/name&gt;</code> <code>&lt;empty</code><code>/&gt;</code><code> &lt;/element&gt;</code>
</div><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  deref(<code>"bar2.element"</code>) = <code>&lt;element&gt; </code><code>&lt;name</code><code> ns="</code><code>http://www.example.com/n2</code><code>"</code><code>&gt;</code> <code>"bar2"</code> <code>&lt;/name&gt;</code> <code>&lt;empty</code><code>/&gt;</code><code> &lt;/element&gt;</code>
</div><p>Let name class <i>nc</i><sub>1</sub> be</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <code>&lt;name</code><code> ns="</code><code>http://www.example.com/n1</code><code>"</code><code>&gt;</code> <code>"bar1"</code> <code>&lt;/name&gt;</code>
</div><p>and let <i>nc</i><sub>2</sub> be</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <code>&lt;name</code><code> ns="</code><code>http://www.example.com/n2</code><code>"</code><code>&gt;</code> <code>"bar2"</code> <code>&lt;/name&gt;</code>
</div><p>Then, by the inference rule (name) in <a class="xref" href="#name-classes" title="6.1.&nbsp;Name classes">Section&nbsp;6.1, &#x201c;Name classes&#x201d;</a>, we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  name( <code>"http://www.example.com/n1"</code>, <code>"bar1"</code> ) in <i>nc</i><sub>1</sub>
</div><p>and</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  name( <code>"http://www.example.com/n2"</code>, <code>"bar2"</code> ) in <i>nc</i><sub>2</sub>
</div><p>By the inference rule (empty) in <a class="xref" href="#empty-pattern" title="6.2.3.&nbsp;empty pattern">Section&nbsp;6.2.3, &#x201c;<code class="literal">empty</code> pattern&#x201d;</a>,
we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>1</sub> |- { }; ( ) =~ <code>&lt;empty</code><code>/&gt;</code>
</div><p>and</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>2</sub> |- { }; ( ) =~ <code>&lt;empty</code><code>/&gt;</code>
</div><p>Thus by the inference rule (element) in <a class="xref" href="#element-pattern" title="6.2.7.&nbsp;element and attribute pattern">Section&nbsp;6.2.7, &#x201c;<code class="literal">element</code> and <code class="literal">attribute</code> pattern&#x201d;</a>, we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>0</sub> |- { }; <i>e</i><sub>1</sub> =~ <code>&lt;ref</code><code> name="</code><code>bar1</code><code>"</code><code>/&gt;</code>
</div><p>Note that we have chosen <i>cx</i><sub>0</sub>, since any context is allowed.</p><p>Likewise, we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>0</sub> |- { }; <i>e</i><sub>2</sub> =~ <code>&lt;ref</code><code> name="</code><code>bar2</code><code>"</code><code>/&gt;</code>
</div><p>By the inference rule (group) in <a class="xref" href="#choice-pattern" title="6.2.1.&nbsp;choice pattern">Section&nbsp;6.2.1, &#x201c;<code class="literal">choice</code> pattern&#x201d;</a>, we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>0</sub> |- { }; <i>e</i><sub>1</sub>, <i>e</i><sub>2</sub> =~ <code>&lt;group</code><code>&gt;</code> <code>&lt;ref</code><code> name="</code><code>bar1</code><code>"</code><code>/&gt;</code> <code>&lt;ref</code><code> name="</code><code>bar2</code><code>"</code><code>/&gt;</code> <code>&lt;/group&gt;</code>
</div><p>By the inference rule (element) in <a class="xref" href="#element-pattern" title="6.2.7.&nbsp;element and attribute pattern">Section&nbsp;6.2.7, &#x201c;<code class="literal">element</code> and <code class="literal">attribute</code> pattern&#x201d;</a>, we have</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  <i>cx</i><sub>3</sub> |- { }; element( name( <code>""</code>, <code>"foo"</code> ), <i>cx</i><sub>0</sub>, { }, <i>m</i> ) =~ <code>&lt;ref</code><code> name="</code><code>foo</code><code>"</code><code>/&gt;</code>
</div><p>Here <i>cx</i><sub>3</sub> is an arbitrary
context.</p><p>Thus we can apply the inference rule (valid) in <a class="xref" href="#validity" title="6.3.&nbsp;Validity">Section&nbsp;6.3, &#x201c;Validity&#x201d;</a> and obtain</p><div class="formula" style="margin-left: 0.5in; margin-right: 0.5in;">
  valid(<i>e</i><sub>0</sub>)
</div></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="restriction"></a>7.&nbsp;Restrictions</h2></div></div><p>The following constraints are all checked after the grammar has
been transformed to the simple form described in <a class="xref" href="#simple-syntax" title="5.&nbsp;Simple syntax">Section&nbsp;5, &#x201c;Simple syntax&#x201d;</a>. The purpose of these restrictions is to
catch user errors and to facilitate implementation.</p><div class="section"><div class="titlepage"><div><h3 class="title"><a name="contextual-restriction"></a>7.1.&nbsp;Contextual restrictions</h3></div></div><p>In this section we describe restrictions on where elements are
allowed in the schema based on the names of the ancestor elements. We
use the concept of a <em class="firstterm">prohibited path</em> to
describe these restrictions. A path is a sequence of NCNames separated
by <code class="literal">/</code> or <code class="literal">//</code>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3633"></a>An element matches a path
<em class="replaceable"><code>x</code></em>, where <em class="replaceable"><code>x</code></em> is an
NCName, if and only if the local name of the element is
<em class="replaceable"><code>x</code></em></li><li class="listitem"><a name="d61e3641"></a>An element matches a path
<em class="replaceable"><code>x</code></em><code class="literal">/</code><em class="replaceable"><code>p</code></em>,
where <em class="replaceable"><code>x</code></em> is an NCName and
<em class="replaceable"><code>p</code></em> is a path, if and only if the local name
of the element is <em class="replaceable"><code>x</code></em> and the element has a
child that matches <em class="replaceable"><code>p</code></em></li><li class="listitem"><a name="d61e3656"></a>An element matches a path
<em class="replaceable"><code>x</code></em><code class="literal">//</code><em class="replaceable"><code>p</code></em>,
where <em class="replaceable"><code>x</code></em> is an NCName and
<em class="replaceable"><code>p</code></em> is a path, if and only if the local name
of the element is <em class="replaceable"><code>x</code></em> and the element has a
descendant that matches <em class="replaceable"><code>p</code></em></li></ul></div><p>For example, the element</p><pre class="programlisting">&lt;foo&gt;
  &lt;bar&gt;
    &lt;baz/&gt;
  &lt;/bar&gt;
&lt;/foo&gt;</pre><p>matches the paths <code class="literal">foo</code>,
<code class="literal">foo/bar</code>, <code class="literal">foo//bar</code>,
<code class="literal">foo//baz</code>, <code class="literal">foo/bar/baz</code>,
<code class="literal">foo/bar//baz</code> and <code class="literal">foo//bar/baz</code>,
but not <code class="literal">foo/baz</code> or
<code class="literal">foobar</code>.</p><p>A correct RELAX NG schema must be such that, after
transformation to the simple form, it does not contain any element
that matches a prohibited path.</p><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e3695"></a>7.1.1.&nbsp;<code class="literal">attribute</code> pattern</h4></div></div><p>The following paths are prohibited:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3701"></a><code class="literal">attribute//ref</code></li><li class="listitem"><a name="d61e3704"></a><code class="literal">attribute//attribute</code></li></ul></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="d61e3707"></a>7.1.2.&nbsp;<code class="literal">oneOrMore</code> pattern</h4></div></div><p>The following paths are prohibited:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3713"></a><code class="literal">oneOrMore//group//attribute</code></li><li class="listitem"><a name="d61e3716"></a><code class="literal">oneOrMore//interleave//attribute</code></li></ul></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="list-restrictions"></a>7.1.3.&nbsp;<code class="literal">list</code> pattern</h4></div></div><p>The following paths are prohibited:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3725"></a><code class="literal">list//list</code></li><li class="listitem"><a name="d61e3728"></a><code class="literal">list//ref</code></li><li class="listitem"><a name="d61e3731"></a><code class="literal">list//attribute</code></li><li class="listitem"><a name="d61e3734"></a><code class="literal">list//text</code></li><li class="listitem"><a name="d61e3737"></a><code class="literal">list//interleave</code></li></ul></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="context-data-except"></a>7.1.4.&nbsp;<code class="literal">except</code> in <code class="literal">data</code> pattern</h4></div></div><p>The following paths are prohibited:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3748"></a><code class="literal">data/except//attribute</code></li><li class="listitem"><a name="d61e3751"></a><code class="literal">data/except//ref</code></li><li class="listitem"><a name="d61e3754"></a><code class="literal">data/except//text</code></li><li class="listitem"><a name="d61e3757"></a><code class="literal">data/except//list</code></li><li class="listitem"><a name="d61e3760"></a><code class="literal">data/except//group</code></li><li class="listitem"><a name="d61e3763"></a><code class="literal">data/except//interleave</code></li><li class="listitem"><a name="d61e3766"></a><code class="literal">data/except//oneOrMore</code></li><li class="listitem"><a name="d61e3769"></a><code class="literal">data/except//empty</code></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This implies that an <code class="literal">except</code> element
with a <code class="literal">data</code> parent can contain only
<code class="literal">data</code>, <code class="literal">value</code> and
<code class="literal">choice</code> elements.</p></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="context-start"></a>7.1.5.&nbsp;<code class="literal">start</code> element</h4></div></div><p>The following paths are prohibited:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3792"></a><code class="literal">start//attribute</code></li><li class="listitem"><a name="d61e3795"></a><code class="literal">start//data</code></li><li class="listitem"><a name="d61e3798"></a><code class="literal">start//value</code></li><li class="listitem"><a name="d61e3801"></a><code class="literal">start//text</code></li><li class="listitem"><a name="d61e3804"></a><code class="literal">start//list</code></li><li class="listitem"><a name="d61e3807"></a><code class="literal">start//group</code></li><li class="listitem"><a name="d61e3810"></a><code class="literal">start//interleave</code></li><li class="listitem"><a name="d61e3813"></a><code class="literal">start//oneOrMore</code></li><li class="listitem"><a name="d61e3816"></a><code class="literal">start//empty</code></li></ul></div></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="string-sequences"></a>7.2.&nbsp;String sequences</h3></div></div><p>RELAX NG does not allow a pattern such as:</p><pre class="programlisting">&lt;element name="foo"&gt;
  &lt;group&gt;
    &lt;data type="int"/&gt;
    &lt;element name="bar"&gt;
      &lt;empty/&gt;
    &lt;/element&gt;
  &lt;/group&gt;
&lt;/element&gt;</pre><p>Nor does it allow a pattern such as:</p><pre class="programlisting">&lt;element name="foo"&gt;
  &lt;group&gt;
    &lt;data type="int"/&gt;
    &lt;text/&gt;
  &lt;/group&gt;
&lt;/element&gt;</pre><p>More generally, if the pattern for the content of an element or
attribute contains</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e3827"></a>a pattern that can match a child
(that is, an <code class="literal">element</code>, <code class="literal">data</code>,
<code class="literal">value</code>, <code class="literal">list</code> or
<code class="literal">text</code> pattern), and</li><li class="listitem"><a name="d61e3840"></a>a pattern that matches a single string (that is, a
<code class="literal">data</code>, <code class="literal">value</code> or
<code class="literal">list</code> pattern),</li></ul></div><p>then the two patterns must be alternatives to each other.</p><p>This rule does not apply to patterns occurring within a
<code class="literal">list</code> pattern.</p><p>To formalize this, we use the concept of a content-type.  A
pattern that is allowable as the content of an element has one of
three content-types: empty, complex and simple.  We use the following
notation.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">empty(  )</span></dt><dd><a name="d61e3859"></a>returns the empty content-type</dd><dt><span class="term">complex(  )</span></dt><dd><a name="d61e3864"></a>returns the complex content-type</dd><dt><span class="term">simple(  )</span></dt><dd><a name="d61e3869"></a>returns the simple content-type</dd><dt><span class="term"><i>ct</i></span></dt><dd><a name="d61e3874"></a>ranges over content-types</dd><dt><span class="term">
  groupable(<i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub>)
</span></dt><dd><a name="d61e3886"></a>asserts that the content-types <i>ct</i><sub>1</sub> and <i>ct</i><sub>2</sub>
are groupable</dd></dl></div><p>The empty content-type is groupable with anything.  In addition,
the complex content-type is groupable with the complex content-type. The
following rules formalize this.</p>
<table cellspacing="20"><tr valign="center"><td>(group empty 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">groupable(empty(  ), <i>ct</i>)</td></tr></table></td></tr></table>
<table cellspacing="20"><tr valign="center"><td>(group empty 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">groupable(<i>ct</i>, empty(  ))</td></tr></table></td></tr></table>
<table cellspacing="20"><tr valign="center"><td>(group complex)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0">groupable(complex(  ), complex(  ))</td></tr></table></td></tr></table>
<p>Some patterns have a content-type. We use the following
additional notation.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
  <i>p</i> <b>:</b><sub>c</sub> <i>ct</i>
</span></dt><dd><a name="d61e3939"></a>asserts that pattern <i>p</i> has
content-type <i>ct</i></dd><dt><span class="term">
  max( <i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub> )
</span></dt><dd><a name="d61e3955"></a>returns the maximum of <i>ct</i><sub>1</sub> and <i>ct</i><sub>2</sub> where the
content-types in increasing order are empty(  ),
complex(  ), simple(  )</dd></dl></div><p>The following rules define when a pattern has a content-type and,
if so, what it is.</p>
<table cellspacing="20"><tr valign="center"><td>(value)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;value</code><code> datatypeLibrary="</code><i>u</i><sub>1</sub><code>"</code><code> type="</code><i>ln</i><code>"</code><code> ns="</code><i>u</i><sub>2</sub><code>"</code><code>&gt;</code> <i>s</i> <code>&lt;/value&gt;</code> <b>:</b><sub>c</sub> simple(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(data 1)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;data</code><code> datatypeLibrary="</code><i>u</i><code>"</code><code> type="</code><i>ln</i><code>"</code><code>&gt;</code> <i>params</i> <code>&lt;/data&gt;</code> <b>:</b><sub>c</sub> simple(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(data 2)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i> <b>:</b><sub>c</sub> <i>ct</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><code>&lt;data</code><code> datatypeLibrary="</code><i>u</i><code>"</code><code> type="</code><i>ln</i><code>"</code><code>&gt;</code> <i>params</i> <code>&lt;except</code><code>&gt;</code> <i>p</i> <code>&lt;/except&gt;</code> <code>&lt;/data&gt;</code> <b>:</b><sub>c</sub> simple(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(list)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;list</code><code>&gt;</code> <i>p</i> <code>&lt;/list&gt;</code> <b>:</b><sub>c</sub> simple(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(text)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;text</code><code>/&gt;</code> <b>:</b><sub>c</sub> complex(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(ref)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;ref</code><code> name="</code><i>ln</i><code>"</code><code>/&gt;</code> <b>:</b><sub>c</sub> complex(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(empty)</td><td><table cellpadding="0" cellspacing="0"><tr align="center"><td colspan="0"><code>&lt;empty</code><code>/&gt;</code> <b>:</b><sub>c</sub> empty(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(attribute)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i> <b>:</b><sub>c</sub> <i>ct</i></td></tr><tr><td colspan="1"><hr noshade></td></tr><tr align="center"><td colspan="1"><code>&lt;attribute</code><code>&gt;</code> <i>nc</i> <i>p</i> <code>&lt;/attribute&gt;</code> <b>:</b><sub>c</sub> empty(  )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(group)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i><sub>1</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>1</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>p</i><sub>2</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>2</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;groupable(<i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub>)</td></tr><tr><td colspan="3"><hr noshade></td></tr><tr align="center"><td colspan="3"><code>&lt;group</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/group&gt;</code> <b>:</b><sub>c</sub> max( <i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub> )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(interleave)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i><sub>1</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>1</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>p</i><sub>2</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>2</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;groupable(<i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub>)</td></tr><tr><td colspan="3"><hr noshade></td></tr><tr align="center"><td colspan="3"><code>&lt;interleave</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/interleave&gt;</code> <b>:</b><sub>c</sub> max( <i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub> )</td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(oneOrMore)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i> <b>:</b><sub>c</sub> <i>ct</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;groupable(<i>ct</i>, <i>ct</i>)</td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2"><code>&lt;oneOrMore</code><code>&gt;</code> <i>p</i> <code>&lt;/oneOrMore&gt;</code> <b>:</b><sub>c</sub> <i>ct</i></td></tr></table></td></tr></table>

<table cellspacing="20"><tr valign="center"><td>(choice)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td><i>p</i><sub>1</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>1</sub></td><td>&nbsp;&nbsp;&nbsp;&nbsp;<i>p</i><sub>2</sub> <b>:</b><sub>c</sub> <i>ct</i><sub>2</sub></td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2"><code>&lt;choice</code><code>&gt;</code> <i>p</i><sub>1</sub> <i>p</i><sub>2</sub> <code>&lt;/choice&gt;</code> <b>:</b><sub>c</sub> max( <i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub> )</td></tr></table></td></tr></table>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The antecedent in the (data 2) rule above is in fact
redundant because of the prohibited paths in <a class="xref" href="#context-data-except" title="7.1.4.&nbsp;except in data pattern">Section&nbsp;7.1.4, &#x201c;<code class="literal">except</code> in <code class="literal">data</code> pattern&#x201d;</a>.</p></div><p>Now we can describe the restriction. We use the following
notation.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
  incorrectSchema()
</span></dt><dd><a name="d61e4284"></a>asserts that the schema is incorrect</dd></dl></div><p>All patterns occurring as the content of an element pattern must
have a content-type.</p>

<table cellspacing="20"><tr valign="center"><td>(element)</td><td><table cellpadding="0" cellspacing="0"><tr align="center" width="100%" valign="baseline"><td>deref(<i>ln</i>) = <code>&lt;element&gt; </code><i>nc</i> <i>p</i><code> &lt;/element&gt;</code></td><td>&nbsp;&nbsp;&nbsp;&nbsp;not(<i>p</i> <b>:</b><sub>c</sub> <i>ct</i>)</td></tr><tr><td colspan="2"><hr noshade></td></tr><tr align="center"><td colspan="2">incorrectSchema()</td></tr></table></td></tr></table>

</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="attribute-restrictions"></a>7.3.&nbsp;Restrictions on attributes</h3></div></div><p>Duplicate attributes are not allowed.  More precisely, for a
pattern <code class="literal">&lt;group&gt; <em class="replaceable"><code>p1</code></em>
<em class="replaceable"><code>p2</code></em> &lt;/group&gt;</code> or
<code class="literal">&lt;interleave&gt; <em class="replaceable"><code>p1</code></em>
<em class="replaceable"><code>p2</code></em> &lt;/interleave&gt;</code>, there must
not be a name that belongs to both the name class of an
<code class="literal">attribute</code> pattern occurring in
<em class="replaceable"><code>p1</code></em> and the name class of an
<code class="literal">attribute</code> pattern occurring in
<em class="replaceable"><code>p2</code></em>. A pattern <em class="replaceable"><code>p1</code></em>
is defined to <em class="firstterm">occur in</em> a pattern
<em class="replaceable"><code>p2</code></em> if</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e4347"></a><em class="replaceable"><code>p1</code></em> is
<em class="replaceable"><code>p2</code></em>, or</li><li class="listitem"><a name="d61e4353"></a><em class="replaceable"><code>p2</code></em> is a
<code class="literal">choice</code>, <code class="literal">interleave</code>,
<code class="literal">group</code> or <code class="literal">oneOrMore</code> element and
<em class="replaceable"><code>p1</code></em> occurs in one or more children of
<em class="replaceable"><code>p2</code></em>.</li></ul></div><p>Attributes using infinite name classes must be repeated.  More
precisely, an <code class="literal">attribute</code> element that has an
<code class="literal">anyName</code> or <code class="literal">nsName</code> descendant
element must have a <code class="literal">oneOrMore</code> ancestor
element.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This restriction is necessary for closure under
negation.</p></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="interleave-restrictions"></a>7.4.&nbsp;Restrictions on <code class="literal">interleave</code></h3></div></div><p>For a pattern <code class="literal">&lt;interleave&gt;
<em class="replaceable"><code>p1</code></em> <em class="replaceable"><code>p2</code></em>
&lt;/interleave&gt;</code>,</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e4396"></a>there must not be a name that belongs to both the name
class of an <code class="literal">element</code> pattern referenced by a
<code class="literal">ref</code> pattern occurring in
<em class="replaceable"><code>p1</code></em> and the name class of an
<code class="literal">element</code> pattern referenced by a
<code class="literal">ref</code> pattern occurring in
<em class="replaceable"><code>p2</code></em>, and</li><li class="listitem"><a name="d61e4412"></a>a <code class="literal">text</code> pattern must not occur in
both <em class="replaceable"><code>p1</code></em> and
<em class="replaceable"><code>p2</code></em>.</li></ul></div><p><a class="xref" href="#attribute-restrictions" title="7.3.&nbsp;Restrictions on attributes">Section&nbsp;7.3, &#x201c;Restrictions on attributes&#x201d;</a> defines when one
pattern is considered to occur in another pattern.</p></div></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="conformance"></a>8.&nbsp;Conformance</h2></div></div><p>A conforming RELAX NG validator must be able to determine for
any XML document whether it is a correct RELAX NG schema.  A
conforming RELAX NG validator must be able to determine for any XML
document and for any correct RELAX NG schema whether the document is
valid with respect to the schema.</p><p>However, the requirements in the preceding paragraph do not
apply if the schema uses a datatype library that the validator does
not support.  A conforming RELAX NG validator is only required to
support the built-in datatype library described in <a class="xref" href="#built-in-datatype" title="6.2.9.&nbsp;Built-in datatype library">Section&nbsp;6.2.9, &#x201c;Built-in datatype library&#x201d;</a>.  A validator that claims conformance to
RELAX NG should document which datatype libraries it supports.  The
requirements in the preceding paragraph also do not apply if the
schema includes <code class="literal">externalRef</code> or
<code class="literal">include</code> elements and the validator is unable to
retrieve the resource identified by the URI or is unable to construct
an element from the retrieved resource.  A validator that claims
conformance to RELAX NG should document its capabilities for handling
URI references.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="d61e4435"></a>A.&nbsp;RELAX NG schema for RELAX NG</h2><pre>&lt;grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  ns="http://relaxng.org/ns/structure/1.0"
  xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;ref name="<a href="#:pattern">pattern</a>"/&gt;
  &lt;/start&gt;

  <a name=":pattern"></a>&lt;define name="pattern"&gt;
    &lt;choice&gt;
      &lt;element name="element"&gt;
        &lt;choice&gt;
          &lt;attribute name="name"&gt;
            &lt;data type="QName"/&gt;
          &lt;/attribute&gt;
          &lt;ref name="<a href="#:open-name-class">open-name-class</a>"/&gt;
        &lt;/choice&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="attribute"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;choice&gt;
          &lt;attribute name="name"&gt;
            &lt;data type="QName"/&gt;
          &lt;/attribute&gt;
          &lt;ref name="<a href="#:open-name-class">open-name-class</a>"/&gt;
        &lt;/choice&gt;
        &lt;interleave&gt;
          &lt;ref name="<a href="#:other">other</a>"/&gt;
          &lt;optional&gt;
            &lt;ref name="<a href="#:pattern">pattern</a>"/&gt;
          &lt;/optional&gt;
        &lt;/interleave&gt;
      &lt;/element&gt;
      &lt;element name="group"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="interleave"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="choice"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="optional"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="zeroOrMore"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="oneOrMore"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="list"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="mixed"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="ref"&gt;
        &lt;attribute name="name"&gt;
          &lt;data type="NCName"/&gt;
        &lt;/attribute&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="parentRef"&gt;
        &lt;attribute name="name"&gt;
          &lt;data type="NCName"/&gt;
        &lt;/attribute&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="empty"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="text"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="value"&gt;
        &lt;optional&gt;
          &lt;attribute name="type"&gt;
            &lt;data type="NCName"/&gt;
          &lt;/attribute&gt;
        &lt;/optional&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="data"&gt;
        &lt;attribute name="type"&gt;
          &lt;data type="NCName"/&gt;
        &lt;/attribute&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;interleave&gt;
          &lt;ref name="<a href="#:other">other</a>"/&gt;
          &lt;group&gt;
            &lt;zeroOrMore&gt;
              &lt;element name="param"&gt;
                &lt;attribute name="name"&gt;
                  &lt;data type="NCName"/&gt;
                &lt;/attribute&gt;
                &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
                &lt;text/&gt;
              &lt;/element&gt;
            &lt;/zeroOrMore&gt;
            &lt;optional&gt;
              &lt;element name="except"&gt;
                &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
                &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
              &lt;/element&gt;
            &lt;/optional&gt;
          &lt;/group&gt;
        &lt;/interleave&gt;
      &lt;/element&gt;
      &lt;element name="notAllowed"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="externalRef"&gt;
        &lt;attribute name="href"&gt;
          &lt;data type="anyURI"/&gt;
        &lt;/attribute&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="grammar"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:grammar-content">grammar-content</a>"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;

  <a name=":grammar-content"></a>&lt;define name="grammar-content"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;ref name="<a href="#:start-element">start-element</a>"/&gt;
          &lt;ref name="<a href="#:define-element">define-element</a>"/&gt;
          &lt;element name="div"&gt;
            &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
            &lt;ref name="<a href="#:grammar-content">grammar-content</a>"/&gt;
          &lt;/element&gt;
          &lt;element name="include"&gt;
            &lt;attribute name="href"&gt;
              &lt;data type="anyURI"/&gt;
            &lt;/attribute&gt;
            &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
            &lt;ref name="<a href="#:include-content">include-content</a>"/&gt;
          &lt;/element&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":include-content"></a>&lt;define name="include-content"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;ref name="<a href="#:start-element">start-element</a>"/&gt;
          &lt;ref name="<a href="#:define-element">define-element</a>"/&gt;
          &lt;element name="div"&gt;
            &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
            &lt;ref name="<a href="#:include-content">include-content</a>"/&gt;
          &lt;/element&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":start-element"></a>&lt;define name="start-element"&gt;
    &lt;element name="start"&gt;
      &lt;ref name="<a href="#:combine-att">combine-att</a>"/&gt;
      &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
      &lt;ref name="<a href="#:open-pattern">open-pattern</a>"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  <a name=":define-element"></a>&lt;define name="define-element"&gt;
    &lt;element name="define"&gt;
      &lt;attribute name="name"&gt;
        &lt;data type="NCName"/&gt;
      &lt;/attribute&gt;
      &lt;ref name="<a href="#:combine-att">combine-att</a>"/&gt;
      &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
      &lt;ref name="<a href="#:open-patterns">open-patterns</a>"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  <a name=":combine-att"></a>&lt;define name="combine-att"&gt;
    &lt;optional&gt;
      &lt;attribute name="combine"&gt;
        &lt;choice&gt;
          &lt;value&gt;choice&lt;/value&gt;
          &lt;value&gt;interleave&lt;/value&gt;
        &lt;/choice&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

  <a name=":open-patterns"></a>&lt;define name="open-patterns"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="<a href="#:pattern">pattern</a>"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":open-pattern"></a>&lt;define name="open-pattern"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;ref name="<a href="#:pattern">pattern</a>"/&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":name-class"></a>&lt;define name="name-class"&gt;
    &lt;choice&gt;
      &lt;element name="name"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;data type="QName"/&gt;
      &lt;/element&gt;
      &lt;element name="anyName"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:except-name-class">except-name-class</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="nsName"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:except-name-class">except-name-class</a>"/&gt;
      &lt;/element&gt;
      &lt;element name="choice"&gt;
        &lt;ref name="<a href="#:common-atts">common-atts</a>"/&gt;
        &lt;ref name="<a href="#:open-name-classes">open-name-classes</a>"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;

  <a name=":except-name-class"></a>&lt;define name="except-name-class"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;optional&gt;
        &lt;element name="except"&gt;
          &lt;ref name="<a href="#:open-name-classes">open-name-classes</a>"/&gt;
        &lt;/element&gt;
      &lt;/optional&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":open-name-classes"></a>&lt;define name="open-name-classes"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="<a href="#:name-class">name-class</a>"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":open-name-class"></a>&lt;define name="open-name-class"&gt;
    &lt;interleave&gt;
      &lt;ref name="<a href="#:other">other</a>"/&gt;
      &lt;ref name="<a href="#:name-class">name-class</a>"/&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

  <a name=":common-atts"></a>&lt;define name="common-atts"&gt;
    &lt;optional&gt;
      &lt;attribute name="ns"/&gt;
    &lt;/optional&gt;
    &lt;optional&gt;
      &lt;attribute name="datatypeLibrary"&gt;
        &lt;data type="anyURI"/&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
    &lt;zeroOrMore&gt;
      &lt;attribute&gt;
        &lt;anyName&gt;
          &lt;except&gt;
            &lt;nsName/&gt;
            &lt;nsName ns=""/&gt;
          &lt;/except&gt;
        &lt;/anyName&gt;
      &lt;/attribute&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  <a name=":other"></a>&lt;define name="other"&gt;
    &lt;zeroOrMore&gt;
      &lt;element&gt;
        &lt;anyName&gt;
          &lt;except&gt;
            &lt;nsName/&gt;
          &lt;/except&gt;
        &lt;/anyName&gt;
        &lt;zeroOrMore&gt;
          &lt;choice&gt;
            &lt;attribute&gt;
              &lt;anyName/&gt;
            &lt;/attribute&gt;
            &lt;text/&gt;
            &lt;ref name="<a href="#:any">any</a>"/&gt;
          &lt;/choice&gt;
        &lt;/zeroOrMore&gt;
      &lt;/element&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  <a name=":any"></a>&lt;define name="any"&gt;
    &lt;element&gt;
      &lt;anyName/&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;attribute&gt;
            &lt;anyName/&gt;
          &lt;/attribute&gt;
          &lt;text/&gt;
          &lt;ref name="<a href="#:any">any</a>"/&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;
</pre></div><div class="appendix"><h2 class="title" style="clear: both"><a name="d61e4438"></a>B.&nbsp;Changes since version 0.9</h2><p>The changes in this version relative to version 0.9
are as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e4442"></a>in the namespace URI, <code class="literal">0.9</code> has been
changed to <code class="literal">1.0</code></li><li class="listitem"><a name="d61e4448"></a><code class="literal">data/except//empty</code> has been added
as a prohibited path (see <a class="xref" href="#context-data-except" title="7.1.4.&nbsp;except in data pattern">Section&nbsp;7.1.4, &#x201c;<code class="literal">except</code> in <code class="literal">data</code> pattern&#x201d;</a>)</li><li class="listitem"><a name="d61e4454"></a><code class="literal">start//empty</code> has been added
as a prohibited path (see <a class="xref" href="#context-start" title="7.1.5.&nbsp;start element">Section&nbsp;7.1.5, &#x201c;<code class="literal">start</code> element&#x201d;</a>)</li><li class="listitem"><a name="d61e4460"></a><a class="xref" href="#number-child-elements" title="4.12.&nbsp;Number of child elements">Section&nbsp;4.12, &#x201c;Number of child elements&#x201d;</a> now specifies how a
<code class="literal">list</code> element with more than one child element is
transformed</li><li class="listitem"><a name="d61e4466"></a><a class="xref" href="#notAllowed" title="4.20.&nbsp;notAllowed element">Section&nbsp;4.20, &#x201c;<code class="literal">notAllowed</code> element&#x201d;</a> now specifies how a
<code class="literal">notAllowed</code> element occurring in an
<code class="literal">except</code> element is transformed</li><li class="listitem"><a name="d61e4474"></a>although a relative URI is not allowed as the value of
the <code class="literal">ns</code> and <code class="literal">datatypeLibrary</code>
attributes, an empty string is allowed (see <a class="xref" href="#full-syntax" title="3.&nbsp;Full syntax">Section&nbsp;3, &#x201c;Full syntax&#x201d;</a>)</li><li class="listitem"><a name="d61e4483"></a>the removal of unreachable definitions in <a class="xref" href="#define-ref" title="4.19.&nbsp;define and ref elements">Section&nbsp;4.19, &#x201c;<code class="literal">define</code> and <code class="literal">ref</code> elements&#x201d;</a> is now correctly specified</li><li class="listitem"><a name="d61e4488"></a><a class="xref" href="#notAllowed" title="4.20.&nbsp;notAllowed element">Section&nbsp;4.20, &#x201c;<code class="literal">notAllowed</code> element&#x201d;</a> now specifies that
<code class="literal">define</code> elements that are no longer reachable are
removed</li><li class="listitem"><a name="d61e4494"></a><a class="xref" href="#constraints" title="4.16.&nbsp;Constraints">Section&nbsp;4.16, &#x201c;Constraints&#x201d;</a> has been added; the
restrictions on the contents of <code class="literal">except</code> in name
classes that are now specified in the newly added section were
previously specified in a subsection of <a class="xref" href="#contextual-restriction" title="7.1.&nbsp;Contextual restrictions">Section&nbsp;7.1, &#x201c;Contextual restrictions&#x201d;</a>, which has been
removed</li><li class="listitem"><a name="d61e4502"></a>the treatment of element and attribute values that
consist only of whitespace has been refined (see <a class="xref" href="#element-pattern" title="6.2.7.&nbsp;element and attribute pattern">Section&nbsp;6.2.7, &#x201c;<code class="literal">element</code> and <code class="literal">attribute</code> pattern&#x201d;</a> and <a class="xref" href="#data-pattern" title="6.2.8.&nbsp;data and value pattern">Section&nbsp;6.2.8, &#x201c;<code class="literal">data</code> and <code class="literal">value</code> pattern&#x201d;</a>)</li><li class="listitem"><a name="d61e4509"></a>attributes with infinite name classes are now required
to be repeated (see <a class="xref" href="#attribute-restrictions" title="7.3.&nbsp;Restrictions on attributes">Section&nbsp;7.3, &#x201c;Restrictions on attributes&#x201d;</a>)</li><li class="listitem"><a name="d61e4515"></a>restrictions have been imposed on
<code class="literal">interleave</code> (see <a class="xref" href="#interleave-restrictions" title="7.4.&nbsp;Restrictions on interleave">Section&nbsp;7.4, &#x201c;Restrictions on <code class="literal">interleave</code>&#x201d;</a>); <code class="literal">list//interleave</code>
has been added as a prohibited path (see <a class="xref" href="#list-restrictions" title="7.1.3.&nbsp;list pattern">Section&nbsp;7.1.3, &#x201c;<code class="literal">list</code> pattern&#x201d;</a>)</li><li class="listitem"><a name="d61e4526"></a>some of the prohibited paths in <a class="xref" href="#contextual-restriction" title="7.1.&nbsp;Contextual restrictions">Section&nbsp;7.1, &#x201c;Contextual restrictions&#x201d;</a> have been corrected to use
<code class="literal">ref</code> rather than
<code class="literal">element</code></li><li class="listitem"><a name="d61e4534"></a>an error in the inference rule (text 1) in <a class="xref" href="#text-pattern" title="6.2.4.&nbsp;text pattern">Section&nbsp;6.2.4, &#x201c;<code class="literal">text</code> pattern&#x201d;</a> has been corrected</li><li class="listitem"><a name="d61e4539"></a>the value of the <code class="literal">ns</code> attribute is
now unconstrained (see <a class="xref" href="#full-syntax" title="3.&nbsp;Full syntax">Section&nbsp;3, &#x201c;Full syntax&#x201d;</a>)</li></ul></div></div><div class="appendix"><h2 class="title" style="clear: both"><a name="d61e4547"></a>C.&nbsp;RELAX NG TC (Non-Normative)</h2><p>This specification was prepared and approved for publication by
the RELAX NG TC. The current members of the TC are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="d61e4551"></a>Fabio Arciniegas</li><li class="listitem"><a name="d61e4553"></a>James Clark</li><li class="listitem"><a name="d61e4555"></a>Mike Fitzgerald</li><li class="listitem"><a name="d61e4557"></a>KAWAGUCHI Kohsuke</li><li class="listitem"><a name="d61e4559"></a>Josh Lubell</li><li class="listitem"><a name="d61e4561"></a>MURATA Makoto</li><li class="listitem"><a name="d61e4563"></a>Norman Walsh</li><li class="listitem"><a name="d61e4565"></a>David Webber</li></ul></div></div><div class="bibliography"><div class="titlepage"><div><h2 class="title"><a name="d61e4567"></a>References</h2></div></div><div class="bibliodiv"><h3 class="title"><a name="d61e4569"></a>Normative</h3><dl><dt><abbr class="abbrev">RFC 2396</abbr></dt><dd id="rfc2396" class="bibliomixed"><a name="rfc2396"></a>T. Berners-Lee, R. Fielding, L. Masinter.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.ietf.org/rfc/rfc2396.txt" target="_top">RFC 2396:
Uniform Resource Identifiers (URI): Generic
Syntax</a></em></span>.
IETF (Internet Engineering Task Force). 1998.</dd><dt><abbr class="abbrev">RFC 2732</abbr></dt><dd id="rfc2732" class="bibliomixed"><a name="rfc2732"></a>R. Hinden, B. Carpenter, L. Masinter.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.ietf.org/rfc/rfc2732.txt" target="_top">RFC 2732: Format for Literal IPv6 Addresses in URL's</a></em></span>.
IETF (Internet Engineering Task Force), 1999.</dd><dt><abbr class="abbrev">RFC 3023</abbr></dt><dd id="rfc3023" class="bibliomixed"><a name="rfc3023"></a> M. Murata,
S. St.Laurent, D. Kohn.  <span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.ietf.org/rfc/rfc3023.txt" target="_top">RFC 3023: XML Media
Types</a></em></span>. IETF (Internet Engineering Task Force),
2001.</dd><dt><abbr class="abbrev">XLink</abbr></dt><dd id="xlink" class="bibliomixed"><a name="xlink"></a>Steve DeRose, Eve Maler
and David Orchard, editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/xlink/" target="_top">XML Linking
Language (XLink) Version 1.0</a></em></span>.
W3C (World Wide Web Consortium), 2001.</dd><dt><abbr class="abbrev">XML 1.0</abbr></dt><dd id="xml-rec" class="bibliomixed"><a name="xml-rec"></a>Tim Bray,
Jean Paoli, and
C. M. Sperberg-McQueen, Eve Maler, editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/REC-xml" target="_top">Extensible Markup
Language (XML) 1.0 Second Edition</a></em></span>.
W3C (World Wide Web Consortium), 2000.</dd><dt><abbr class="abbrev">XML Infoset</abbr></dt><dd id="infoset" class="bibliomixed"><a name="infoset"></a>John Cowan, Richard Tobin,
editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/xml-infoset/" target="_top">XML
Information Set</a></em></span>.
W3C (World Wide Web Consortium), 2001.</dd><dt><abbr class="abbrev">XML Namespaces</abbr></dt><dd id="xml-names" class="bibliomixed"><a name="xml-names"></a>Tim Bray,
Dave Hollander,
and Andrew Layman, editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/REC-xml-names/" target="_top">Namespaces in
XML</a></em></span>.
W3C (World Wide Web Consortium), 1999.</dd></dl></div><div class="bibliodiv"><h3 class="title"><a name="d61e4620"></a>Non-Normative</h3><dl><dt><abbr class="abbrev">RELAX</abbr></dt><dd id="relax" class="bibliomixed"><a name="relax"></a>MURATA Makoto.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.xml.gr.jp/relax/" target="_top">RELAX (Regular
Language description for XML)</a></em></span>.  INSTAC
(Information Technology Research and Standardization Center), 2001.</dd><dt><abbr class="abbrev">TREX</abbr></dt><dd id="trex" class="bibliomixed"><a name="trex"></a>James Clark.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.thaiopensource.com/trex/" target="_top">TREX - Tree Regular Expressions for XML</a></em></span>.
Thai Open Source Software Center, 2001.</dd><dt><abbr class="abbrev">Tutorial</abbr></dt><dd id="tutorial" class="bibliomixed"><a name="tutorial"></a>James Clark,
Makoto MURATA, editors.  <span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.oasis-open.org/committees/relax-ng/tutorial.html" target="_top">RELAX
NG Tutorial</a></em></span>.  OASIS, 2001.</dd><dt><abbr class="abbrev">W3C XML Schema Datatypes</abbr></dt><dd id="xmlschema-2" class="bibliomixed"><a name="xmlschema-2"></a>Paul V. Biron, Ashok Malhotra, editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/xmlschema-2/" target="_top">XML Schema Part 2: Datatypes</a></em></span>.
W3C (World Wide Web Consortium), 2001.</dd><dt><abbr class="abbrev">XML Schema Formal</abbr></dt><dd id="xsfd" class="bibliomixed"><a name="xsfd"></a>Allen Brown,
Matthew Fuchs, Jonathan Robie, Philip Wadler, editors.
<span class="citetitle"><em class="citetitle"><a class="ulink" href="http://www.w3.org/TR/xmlschema-formal/" target="_top">XML Schema: Formal Description</a></em></span>.
W3C (World Wide Web Consortium), 2001.</dd></dl></div></div></div></body></html>